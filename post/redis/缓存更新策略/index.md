
> 转载自 https://coolshell.cn/articles/17416.html

# 问题引入

&emsp;&emsp;很多人在写更新缓存数据代码时，**先删除缓存，然后再更新数据库**，而后续的操作会把数据再装载到缓存中。这是有问题的。

&emsp;&emsp;假设，一个更新操作，一个查询操作，并发执行。按照上面的逻辑，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，再缓存中的数据还是老数据，导致缓存中的数据是脏的，而且会永远脏下去。

## 模式探讨

&emsp;&emsp;我们先不讨论`更新缓存`和`更新数据`这两件事是一个**事务**，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况。(**先把代码逻辑写对**)

- 模式

|模式英文名|模式中文名|
|:-:|:-:|
|Cache aside|暂存|
|Read/Write Through|通读，通写|
|Write behind caching|缓存后写|

## Cache aside

&emsp;&emsp;这是最常用的模式了。其具体逻辑如下：

- **失效**： 应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后。放到缓存中。
- **命中**：应用程序从cache中取数据，取到后返回。
- **更新**：先把数据存到数据库，成功后，再让缓存失效。

&emsp;&emsp;OK!我们再来看看该模式是否多线程安全。首先，没有了删除cache数据的操作了，而是先更新数据库中的数据，此时，缓存依然有效，所以，并发查询操作拿的是没有更新的数据，但是，更新操作马上让缓存失效，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头逻辑产生的问题了。

&emsp;&emsp;那么，是不是Cache aside这个模式就不会有并发问题？**不是的**。比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。

&emsp;&emsp;但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

## Read/Write Through

&emsp;&emsp;我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，**应用程序比较啰嗦**。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。

### Read Through

&emsp;&emsp;Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。

### Write Through

&emsp;&emsp;Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）

## Write behind caching

&emsp;&emsp;Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。

&emsp;&emsp;但是，其带来的问题是，**数据不是强一致性的**，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。

# 解决方案

1. 对强一致性要求非常高的系统，应采用`Cache aside`模式，缺点是应用程序复杂，需要自行解决并发安全问题(Java Spring 提供了写时缓存)。
2. 对于并发程度较高的，可以采用`Read/Write Through`模式，比如`mysql UDF 函数`，通过mysql自身函数触发进行数据同步。缺点是学习成本太高(C 语言编写)。
3. 对于并发程序不高的系统，可以采用`Write behind caching`模式，比如`canal kafka 异步消息队列`。缺点是数据不是强一致性的。