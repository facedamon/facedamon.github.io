<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/post/</link>
    <description>Recent content in Posts on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 14 Nov 2020 11:29:55 +0800</lastBuildDate>
    
	<atom:link href="http://facedamon.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[分布式ID生成策略]</title>
      <link>http://facedamon.github.io/post/uid/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sat, 14 Nov 2020 11:29:55 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/uid/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</guid>
      <description>美团 背景 &amp;emsp;&amp;emsp;在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 原型模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 30 Oct 2020 14:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;原型模式(Propertype Pattern)是用于创建重复的对象，同时又能保证性能。 &amp;emsp;&amp;emsp;这</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 建造者模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 27 Oct 2020 17:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;Builder Pattern使用多个简单的对象一步一步构建一个复杂的对象。 介绍 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的</description>
    </item>
    
    <item>
      <title>[分布式缓存 (七) | Protobuf]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</link>
      <pubDate>Wed, 21 Oct 2020 15:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</guid>
      <description>为什么要使用protobuf protobuf既Protocol Buffers, Google开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语</description>
    </item>
    
    <item>
      <title>[分布式缓存 (六) | 防止缓存击穿]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</link>
      <pubDate>Wed, 21 Oct 2020 10:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</guid>
      <description>摘要 缓存雪崩：缓存在同一时刻全部失效，造成瞬间DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的key设置了相同的过期</description>
    </item>
    
    <item>
      <title>[分布式缓存 (五) | 分布式节点]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 20 Oct 2020 10:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</guid>
      <description>流程回顾 1 2 3 4 5 接收key --&amp;gt; 检查是否被缓存 ---是---&amp;gt; 返回缓存值(1) |否 |------&amp;gt;是否应当从远程节点获取 ------&amp;gt; 与远程节</description>
    </item>
    
    <item>
      <title>[分布式缓存 (四) | 一致性HASH]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</link>
      <pubDate>Mon, 19 Oct 2020 09:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;今天我们要实现的是一致性哈希算法，一致性哈希算法是Geec从单节点走向分布式节点的一个重要的环节。 我该访问谁 &amp;e</description>
    </item>
    
    <item>
      <title>[微服务设计 | SaaS]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/saas/</link>
      <pubDate>Fri, 25 Sep 2020 09:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/saas/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;SaaS区别于其他应用程序的主要特征就是能够使客户在使用应用程序时按照使用量付费。他们不需要为软件购买许可，也不</description>
    </item>
    
    <item>
      <title>[微服务设计 | 分布式事务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 17 Sep 2020 10:17:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>转载自 https://juejin.im/post/6844903734753886216 作者 caison@aliyun.com 摘要 &amp;emsp;&amp;emsp;这篇文章主要介绍什么是分布式事务，分布式事务解决什么问题，对分布式事务实现的难点，解决思路，不同场</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 单例模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;单例模式(Singleton Pattern) 是Java中最简单的设计模式之一。它提供了一种创建对象的最佳方法。 &amp;emsp;&amp;e</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 抽象工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 15:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;抽象工厂模式(Abstract Factory Pattern)用于生成产品族的工厂。该工厂又称为其它工厂的工厂。在抽象工厂模式</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 14:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;工厂模式(Factory Pattern)是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为 | 观察者模式实践之电商业务]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 02 Sep 2020 11:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E8%B7%B5/</guid>
      <description>什么是观察者模式 观察者观察被观察者，被观察者通知观察者 &amp;emsp;&amp;emsp;我们用&amp;rdquo;订阅通知&amp;rdquo;翻译下[观察者模式]</description>
    </item>
    
    <item>
      <title>[Redis | 进阶]</title>
      <link>http://facedamon.github.io/post/redis/%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 31 Aug 2020 16:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E8%BF%9B%E9%98%B6/</guid>
      <description>事务 &amp;emsp;&amp;emsp;在微博中，用户之间是&amp;rdquo;关注&amp;rdquo;和&amp;rdquo;被关注&amp;rdquo;的关系。如果要使用Red</description>
    </item>
    
    <item>
      <title>[微服务设计(三) | 集成技术]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/3.-%E9%9B%86%E6%88%90/</link>
      <pubDate>Mon, 24 Aug 2020 16:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/3.-%E9%9B%86%E6%88%90/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;微服务之间通信方式的选择非常多样化，但哪个是正确的呢？SOAP? XML-RPC? REST? Protocol Buffers? 后面会逐一讨论，在此之前需要考虑的是，我</description>
    </item>
    
    <item>
      <title>[Redis | 基础]</title>
      <link>http://facedamon.github.io/post/redis/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 14 Aug 2020 10:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</guid>
      <description>基础类型 string list hash set zset string &amp;emsp;&amp;emsp;一个字符串类型允许存储的数据的最大容量是512MB。 command return set key value 返回ok get key 当key不存在是返回e</description>
    </item>
    
    <item>
      <title>[Redis | 缓存更新策略]</title>
      <link>http://facedamon.github.io/post/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 13 Aug 2020 14:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</guid>
      <description>转载自 https://coolshell.cn/articles/17416.html 问题引入 &amp;emsp;&amp;emsp;很多人在写更新缓存数据代码时，先删除缓存，然后再更新数据库，而后续的操作会把数据再装载到缓存中。这是</description>
    </item>
    
    <item>
      <title>[Redis | 分布式集群环境搭建]</title>
      <link>http://facedamon.github.io/post/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 12 Aug 2020 09:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%90%AD%E5%BB%BA/</guid>
      <description>转载自 https://www.cnblogs.com/esofar/p/10486621.html 摘要 &amp;emsp;&amp;emsp;Redis Cluster 即 Redis 集群，是 Redis 官方在 3.0 版本推出的一套分布式存储方案。完全去中心化，由多个节点组成，所有节点彼此互联。Redis 客户端可以直接</description>
    </item>
    
    <item>
      <title>[树形结构 | 前缀树(敏感词过滤)]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/trie/</link>
      <pubDate>Tue, 28 Jul 2020 16:26:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/trie/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;前缀树，又称字典树。之前在手写http框架(路由)中已经略有介绍。这次我们专门做一个关于前缀树的详细介绍及应用。</description>
    </item>
    
    <item>
      <title>[分布式缓存 (三) | HTTP]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</link>
      <pubDate>Fri, 24 Jul 2020 16:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;分布式缓存需要实现节点间通信，建立基于HTTP的通信机制是比较常见的做法。如果一个节点启动了HTTP服务， 那么这</description>
    </item>
    
    <item>
      <title>[分布式缓存 (二) | 确保一致性]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</link>
      <pubDate>Mon, 20 Jul 2020 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;在上一篇博客中，我们实现了LRU缓存淘汰策略。接下来我们使用sync.RWMutex封装LRU的几个方法，使之支</description>
    </item>
    
    <item>
      <title>[分布式缓存 (一) | LRU 淘汰策略]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</link>
      <pubDate>Mon, 20 Jul 2020 10:32:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</guid>
      <description>淘汰算法简介 &amp;emsp;&amp;emsp;geec的缓存全部存储在内存中，内存是有限的，因此不可能无限制添加数据。假定，我们设置缓存能够使用的内存</description>
    </item>
    
    <item>
      <title>[谈谈分布式缓存 (零) | golang cache]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 20 Jul 2020 09:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。我想这是大部分人对于缓存的理解。在</description>
    </item>
    
    <item>
      <title>[手写http框架 (六) | golang recover]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</link>
      <pubDate>Fri, 17 Jul 2020 09:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;在go中，比较常见的错误处理方式是返回error，由调用者巨顶后续如何处理。但是如果是无法恢复的错误，可以手动触</description>
    </item>
    
    <item>
      <title>[手写http框架 (五) | golang middleware]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</link>
      <pubDate>Thu, 16 Jul 2020 10:30:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;中间件(middleware)，简单的说，就是非业务的技术类组件。http框架本身不可能去理解所有的业务，因而不</description>
    </item>
    
    <item>
      <title>[手写http框架 (四) | golang group]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</link>
      <pubDate>Thu, 16 Jul 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;分组控制是http框架提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行</description>
    </item>
    
    <item>
      <title>[手写http框架 (三) | golang router]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</link>
      <pubDate>Tue, 14 Jul 2020 16:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</guid>
      <description>摘要 使用trie树实现动态路由解析 支持两种模式:name和*filepath trie树 &amp;emsp;&amp;emsp;上一节，我们用了一个非常简单的</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (二)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</link>
      <pubDate>Fri, 03 Jul 2020 15:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</guid>
      <description>参见 https://yunlzheng.gitbook.io/prometheus-book/</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (一)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</link>
      <pubDate>Fri, 03 Jul 2020 11:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;由于该系统涉及较多的概念和技术，为了快速上手，第一篇文档主要讲解环境搭建。后期系列文档会逐一解释每一个关键的结点</description>
    </item>
    
    <item>
      <title>[手写http框架 (二) | golang context]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</link>
      <pubDate>Wed, 24 Jun 2020 11:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</guid>
      <description># 摘要 将路由router独立出来，方便之后增强。 设计上下文context，封装Request和Response，提供对JSON、HTML等返</description>
    </item>
    
    <item>
      <title>[手写http框架 (一) | golang http-handler]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</link>
      <pubDate>Tue, 23 Jun 2020 15:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</guid>
      <description>摘要 简单介绍net/http库以及http.Handler接口 搭建Gee框架的雏形 标准库启动Web服务 &amp;emsp;&amp;emsp;Go语言内置了</description>
    </item>
    
    <item>
      <title>[HTTP | golang net/http 源码解读]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Jun 2020 10:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>重要接口 接口名称 简略含义 Handler 处理请求接口 ResponseWriter 返回响应接口 ServeMux 路由 Conn tcp连接 Handler 1 2 3 type Handler interface { ServeHTTP(ResponseWriter, *Request) } &amp;emsp;&amp;emsp;Handler接口是一个</description>
    </item>
    
    <item>
      <title>[mongodb (一) | 基本操作]</title>
      <link>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 09 Jun 2020 09:09:42 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>基本操作 创建document 1 2 #use dbname use chapter; 删除document 1 2 3 #db.dropDatabase() use chapter; db.dropDatabase() 创建collection 1 2 3 #db.createCollection(name, options) # example 集合空间大小614299KB</description>
    </item>
    
    <item>
      <title>[工程师学习方法]</title>
      <link>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 02 Jun 2020 14:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
      <description>环境 &amp;emsp;&amp;emsp;一名工程师在萌芽之中，特别容易自我劝退，偏安一隅。他们有一点解决自己温饱的技术，有一份较为稳定的工作，但他们态度</description>
    </item>
    
    <item>
      <title>[杂谈 | golang接口型函数]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 May 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</guid>
      <description>转载自 https://www.flysnow.org/2016/12/30/golang-function-interface.html 简介 &amp;emsp;&amp;emsp;接口型函数，指的是用函数实现接口，这样在调用的时候就会非常简便，这种方式使用于只有一个函数的接口。 原始接</description>
    </item>
    
    <item>
      <title>[杂谈 | golang database/sql使用]</title>
      <link>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</guid>
      <description>转载自 https://segmentfault.com/a/1190000003036452 概述 &amp;emsp;&amp;emsp;sql.DB不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 川西小环线]</title>
      <link>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</link>
      <pubDate>Fri, 01 May 2020 14:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</guid>
      <description>前言 &amp;emsp;&amp;emsp;2019年国庆是一个值得纪念的日子。这是我第一次长途旅行，这次我放弃了贴吧寻找驴友，上面人多眼杂。几经转折后，相</description>
    </item>
    
    <item>
      <title>[Git (四) | 分支管理(案例驱动)]</title>
      <link>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 30 Apr 2020 09:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;案例，实际工作中你会用到类似的流程。 开发某个网站 为实现某个新的需求，创建分支 在该分支上开展工作 &amp;emsp;&amp;em</description>
    </item>
    
    <item>
      <title>[Git (三) | 分支原理]</title>
      <link>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 29 Apr 2020 16:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;之所以要将Git分支原理单独讲解，主要是想好好理解一下Git的分支模型，这对以后的分支管理学习大有裨益。 简介 &amp;e</description>
    </item>
    
    <item>
      <title>[Git (二) | 上手]</title>
      <link>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Mon, 27 Apr 2020 10:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</guid>
      <description>概要 &amp;emsp;&amp;emsp;希望通过这一节学习，能够快速掌握配置初始化仓库(repository)、开始或停止跟踪(track)文件、暂存(</description>
    </item>
    
    <item>
      <title>[Git (一) | 三种状态和基础配置]</title>
      <link>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 27 Apr 2020 09:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</guid>
      <description>三种状态 &amp;emsp;&amp;emsp;Git有三种状态：已提交(committed), 已修改(modified), 已暂存(staged)。已提交表</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 牛背山]</title>
      <link>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</link>
      <pubDate>Sat, 25 Apr 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</guid>
      <description>四川牛背山之旅 前言 &amp;emsp;&amp;emsp;依稀记得，在2019年元旦时，初来成都，除了工作上的同事，自己没有几个耍得来的要好朋友。一次偶然的</description>
    </item>
    
    <item>
      <title>[nginx (一) | nginx准备]</title>
      <link>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 16 Apr 2020 14:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</guid>
      <description>准备环境 &amp;emsp;&amp;emsp;首先需要一个内核为Linux 2.6及以上版本的操作系统，因为Linux 2.6及以上内核才支持epoll。在l</description>
    </item>
    
    <item>
      <title>[微服务设计(二) | 如何建模服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 13 Apr 2020 09:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;同过上节的讨论，我们已经知道什么是微服务了，你可能已经迫不及待地想要实现它了。但是从何做起呢？在本节中，我们会讨</description>
    </item>
    
    <item>
      <title>[微服务设计(一) | 微服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 12 Apr 2020 13:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 &amp;emsp;&amp;emsp;随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统、模块化的流行，微服务也应运而</description>
    </item>
    
    <item>
      <title>[golang base(十一) | 分布式网络爬虫]</title>
      <link>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 06 Mar 2020 17:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>原因 有一定的复杂性 可以灵活调整项目的复杂性 平衡语言/爬虫之间的比重 爬虫分类 通用爬虫，如baidu，google 聚焦爬虫，从互联网获取结构化数</description>
    </item>
    
    <item>
      <title>[golang base(十) | 广度优先搜索]</title>
      <link>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 05 Mar 2020 15:29:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
      <description>广度优先算法 为爬虫实战做好准备 应用广泛，综合性强 面试常见 &amp;emsp;&amp;emsp;上图中是一个6*5的迷宫，0 代表可以走，1 代表墙，从左上角进</description>
    </item>
    
    <item>
      <title>[golang base(九) | 标准库]</title>
      <link>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Thu, 05 Mar 2020 14:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>http 使用http客户端发送请求 使用http.Client控制请求头部等 使用httputil简化工作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description>
    </item>
    
    <item>
      <title>[golang base(八) | 再谈channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.channel/</link>
      <pubDate>Wed, 04 Mar 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.channel/</guid>
      <description>转载自 https://www.cnblogs.com/sparkdev/ 转载自 https://go-zh.org/ref/mem golang官网内存模型分析 转载自 https://taohuawu.club/high-performance-implementation-of-goroutine-pool 忠告 &amp;emsp;&amp;emsp;程序在修改被多个Go程同时访问的数据时必须序列化该访问。要序</description>
    </item>
    
    <item>
      <title>[golang base(八) | goroutine &amp; channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.-goroutine/</link>
      <pubDate>Wed, 04 Mar 2020 20:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.-goroutine/</guid>
      <description>goroutine 1 2 3 4 5 6 7 8 9 10 11 12 package main func main() { for i := 0; i &amp;lt; 10; i++ { go func(i int){ for { fmt.Printf(&amp;#34;Hello from goroutine %d\n&amp;#34;, i) } }(i) } time.Sleep(time.Millisecond) } &amp;emsp;&amp;emsp;如果不加go关键字的话，就是外循</description>
    </item>
    
    <item>
      <title>[golang base(七) | 测试与性能调优]</title>
      <link>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Sun, 01 Mar 2020 13:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>Debugging Sucks and Testing Rocks 测试 传统测试 VS 表格驱动测试 传统测试 1 2 3 4 @Test public void testAdd() { assertEquals(3, add(1, 2)); assertEquals(Integer.MIN_VALUE, add(1, Integer.MAX_VALUE)); } 测试数据和测试逻辑混在一起 出错信息不明确 一旦一个数据出错测试全部</description>
    </item>
    
    <item>
      <title>[golang base(六) | 错误处理]</title>
      <link>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 28 Feb 2020 17:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>资源管理与出错处理 defer调用 确保在函数结束时调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main func tryDefer() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(&amp;#34;error occurr&amp;#34;) /</description>
    </item>
    
    <item>
      <title>[golang base(五) | 函数式编程]</title>
      <link>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 28 Feb 2020 17:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 函数式编程 VS 函数指针 函数是一等公民：参数，变量，返回值都可以是函数 闭包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main func adder() func(int) int { sum := 0 // 自由变</description>
    </item>
    
    <item>
      <title>[golang base(四) | 面向接口]</title>
      <link>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 28 Feb 2020 17:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口 duck typing 大黄鸭是不是一个鸭子? 传统类型系统：脊索动物，脊椎动物亚门，鸟纲雁形目。。。:no duck typing :yes，像鸭子走路，像鸭子叫，那么就是鸭子 描</description>
    </item>
    
    <item>
      <title>[golang base(三) | 面向对象]</title>
      <link>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 28 Feb 2020 17:07:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>结构体和方法 golang仅支持封装，不支持继承和多态 golang没有class，只有struct golang结构体没有构造方法这一说法 1 2 3</description>
    </item>
    
    <item>
      <title>[golang base(二) | 内建容器]</title>
      <link>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 28 Feb 2020 15:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</guid>
      <description>数组 &amp;emsp;&amp;emsp;数量写在类型的前面 1 2 3 4 5 6 7 8 9 10 11 func main() { // var 需要确定大小，可以不用初始化赋值 var arr1 [5]int // 简化，需要确定大小，需</description>
    </item>
    
    <item>
      <title>[golang base(一) | 基础语法]</title>
      <link>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 28 Feb 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>变量定义 &amp;emsp;&amp;emsp;在golang中变量名在前变量类型在后 &amp;emsp;&amp;emsp;这样设计的初衷是什么?我们回想一下使用其它语言</description>
    </item>
    
    <item>
      <title>[杂谈 | golang设计哲学 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link>
      <pubDate>Thu, 02 Jan 2020 14:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid>
      <description>世界是并行的 先不说宇宙，就整个地球来说，世界万物都是并行发生的；天生对并发支持良好的go语言更容易描述并行的世界。 #世界是由物质组合构成的 微</description>
    </item>
    
    <item>
      <title>[杂谈 | golang发现序列]</title>
      <link>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 02 Jan 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</guid>
      <description>发现了一个好用的golang sql package sqlx，有点类似与java中的dbutils，可以实现结果集的自动映射 sqlx它没有传统ORM的繁琐，毕竟</description>
    </item>
    
    <item>
      <title>[杂谈 | golang是值传递 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 02 Jan 2020 12:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>什么是值传递 &amp;emsp;&amp;emsp;值传递的意思是：函数传递总是原来这个东西的一个副本，一幅拷贝。比如我们传递一个int类型的参数，传递的其</description>
    </item>
    
    <item>
      <title>[树形结构 | 二叉查找树]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</link>
      <pubDate>Thu, 07 Nov 2019 17:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 转载《算法导论》 转载 https://github.com/emirpasic/gods 概要 &amp;emsp;&amp;emsp;本节先对二叉树的相关理论知识进行介绍，然后给出Java的详细实现。关于二叉树的学习</description>
    </item>
    
    <item>
      <title>[线性结构 | 队列]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 05 Nov 2019 17:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 &amp;emsp;&amp;emsp;本节介绍队列的基本原理，然后分别给出队列的Java、Golang两种语言的实现。 队列的介绍 &amp;emsp;&amp;</description>
    </item>
    
    <item>
      <title>[线性结构 | 栈 ]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</link>
      <pubDate>Tue, 05 Nov 2019 10:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 &amp;emsp;&amp;emsp;本节会现对栈的原理进行介绍，然后分别通过Java/Golang三种语言来演示栈的实现示例。 栈的介绍 &amp;em</description>
    </item>
    
    <item>
      <title>[线性结构 | 数组、单链表、双向链表]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 24 Oct 2019 15:31:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 &amp;emsp;&amp;emsp;线性表是一种线性结构，它是具有相同类型的n(n&amp;gt;=0)个元素的有序序列。本节介绍线性表的几个基本组</description>
    </item>
    
    <item>
      <title>[大型网站技术架构 | 架构模式]</title>
      <link>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 15 Oct 2019 10:13:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题和挑战，大型互联网概述在实践中提出了许多解决方案，以实现网站高性能</description>
    </item>
    
    <item>
      <title>[实战笔记(二十二) | Go unsafe内存布局]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 14 Oct 2019 02:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>转载自 https://www.flysnow.org 简介 unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能不要使用它，如果你使用它，看到了这个名字，也会想到</description>
    </item>
    
    <item>
      <title>[实战笔记(二十一) | Go Struct Tag]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</link>
      <pubDate>Mon, 14 Oct 2019 02:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</guid>
      <description>转载自 https://www.flysnow.org JSON字符串对象转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type User struct{ Name string `name` Age int `age` } func main(){ var u User h := `{&amp;#34;name&amp;#34;: &amp;#34;张三&amp;#34;, &amp;#34;age&amp;#34;:15}` err := json.Unmarshall([]byte(h), &amp;amp;u) if err != nil {</description>
    </item>
    
    <item>
      <title>[实战笔记(二十) | Go 反射]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</guid>
      <description>转载自 https://www.flysnow.org 介绍 和java语言一样，Go也实现运行时反射，这为我们提供一种可以在运行时操作任意类型对象的能力。比如我们可以查看一个接口类型变量的</description>
    </item>
    
    <item>
      <title>[实战笔记(十九) | Go 基准测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是基准测试 基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底那种方案性能更好呢？这个时候基准测</description>
    </item>
    
    <item>
      <title>[实战笔记(十八) | Go 单元测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:57:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是单元测试 单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。 大多数的单元测试，都是对某一</description>
    </item>
    
    <item>
      <title>[实战笔记(十七) | Go Context]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</link>
      <pubDate>Mon, 14 Oct 2019 01:56:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</guid>
      <description>转载自 https://www.flysnow.org 前言 控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context，今天我就谈谈Context。 什么是WaitGro</description>
    </item>
    
    <item>
      <title>[实战笔记(十六) | Go Writer Reader]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</link>
      <pubDate>Mon, 14 Oct 2019 01:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</guid>
      <description>转载自 https://www.flysnow.org 输入输出 Go Writer和Reader接口的设计遵循Unix的输入输出，一个程序的输出可以是两个一个程序的输入。它们的功能单一并且纯粹</description>
    </item>
    
    <item>
      <title>[实战笔记(十五) | Go 日志]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 14 Oct 2019 01:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</guid>
      <description>转载自 https://www.flysnow.org 日志使用 日志分析，就是根据输出的日志信息，分析挖掘可能的问题，我们使用fmt.Println系列函数也可以达到目的，因为它们也可以把</description>
    </item>
    
    <item>
      <title>[实战笔记(十四) | Go 读写锁]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Mon, 14 Oct 2019 01:53:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>转载自 https://www.flysnow.org 读写锁 前面的有篇文章在讲资源竞争的时候，讲互斥锁，互斥锁的根本就是当一个goroutine访问的时候，其它goroutine都不能访</description>
    </item>
    
    <item>
      <title>[实战笔记(十三) | Go 并发示例数据库连接池]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 14 Oct 2019 01:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>转载自 https://www.flysnow.org 资源池 这篇文章演示使用有缓冲的通道实现一个资源池，这个资源池可以管理在任意多喝goroutine之间共享的资源，比如网络链接、数据库</description>
    </item>
    
    <item>
      <title>[实战笔记(十二) | Go 并发示例]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载自 https://www.flysnow.org 简介 这篇通过一个例子，演示使用通道来监控程序的执行时间，生命周期，甚至终止程序等等。我们这个程序叫runner，我们可以称之为执行者</description>
    </item>
    
    <item>
      <title>[实战笔记(十一) | Go 通道]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</link>
      <pubDate>Mon, 14 Oct 2019 01:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</guid>
      <description>转载自 https://www.flysnow.org 简介 上一篇，我们讲了原子函数和互斥锁，都可以保证共享数据的读写，但是呢，它们还是有点复杂，而且影响性能，对此，go又为我们提供了一种</description>
    </item>
    
    <item>
      <title>[实战笔记(十) | Go 资源竞争]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</link>
      <pubDate>Mon, 14 Oct 2019 01:49:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</guid>
      <description>转载自 https://www.flysnow.org 概述 有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写，就</description>
    </item>
    
    <item>
      <title>[实战笔记(九) | Go goroutine]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</link>
      <pubDate>Mon, 14 Oct 2019 01:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</guid>
      <description>转载自 https://www.flysnow.org 并发和并行 在谈goroutine之前，我们先谈谈并发和并行。 一般的程序，如果没有特殊的要求的话，是顺序执行的，这样的程序也容易编写维</description>
    </item>
    
    <item>
      <title>[实战笔记(八) | Go 标志符可见性]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Mon, 14 Oct 2019 01:47:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>转载自 https://www.flysnow.org 大小写 go的标志符，这个翻译感觉怪怪的，不过还是按这个起了标题，可以理解为go的变量、类型、字段等。这里的可见性，也就是说那些方法、</description>
    </item>
    
    <item>
      <title>[实战笔记(七) | Go 嵌入类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>转载自 https://www.flysnow.org 组合NO继承 敲入类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。 在其它语言中，有继承可以做同样</description>
    </item>
    
    <item>
      <title>[实战笔记(六) | Go 函数方法]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</guid>
      <description>转载自 https://www.flysnow.org 简介 在Go语言中，函数和方法不太一样，有明确的概念区分。函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是</description>
    </item>
    
    <item>
      <title>[实战笔记(五) | Go Map]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</link>
      <pubDate>Mon, 14 Oct 2019 01:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现(关于Hash散列细枝末节详见Java下的散列表) Map是给予散列表来实现的，就是我们常说的Hash表，所以我们每次迭代m</description>
    </item>
    
    <item>
      <title>[实战笔记(四) | Go切片]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 14 Oct 2019 01:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是</description>
    </item>
    
    <item>
      <title>[实战笔记(三) | Go数组]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。</description>
    </item>
    
    <item>
      <title>[实战笔记(二) | Go command]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</link>
      <pubDate>Mon, 14 Oct 2019 01:41:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</guid>
      <description>转载自 https://www.flysnow.org Go开发工具概览 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Go is a tool for managing for Go source code. Usage: go command [arguments] The command are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information</description>
    </item>
    
    <item>
      <title>[实战笔记(一) | 包管理]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 14 Oct 2019 01:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>转载自 https://www.flysnow.org 1. 包的命名 go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样便于引用，书写以及快速定位查找。 比如go自带的htt</description>
    </item>
    
    <item>
      <title>[Golang内建类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型 聚合类型 引用类型 接口类型 无效类型 数字、字符串、布尔 数组、结构体 指针</description>
    </item>
    
    <item>
      <title>[Golang面试题]</title>
      <link>http://facedamon.github.io/post/golang/interview/golang-1/</link>
      <pubDate>Sat, 12 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/interview/golang-1/</guid>
      <description>此Golang面试题摘自网络，已经找不到作者了，所以使用someone代替。 1. 写出下面代码输出内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;fmt&amp;#34;</description>
    </item>
    
  </channel>
</rss>