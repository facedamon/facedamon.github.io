
>转载自 https://www.flysnow.org

## 1. 内部实现
切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化的好处。
切片对象非常小，是因为它是只有三个字段的数据结构：**一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。**这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。
## 2. 声明和初始化
切片创建的方式有好几种，我们先看下最简洁的make方式。
		slice := make([]int, 5)
使用内置的make函数时，需要传入一个参数，指定切片的长度，例子中我们使用的是5，这时候切片的容量也是5.当然我们也可以单独指定切片的容量。
		slice := make([]int,5,10)
这时，我们创建的切片长度是5，容量是10，需要注意的是这个容量10其实对应的是切片底层数组的。
因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以制定了容量是10，但是我们只能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。
**容量必须>=长度，我们是不能创建长度大于容量的切片的**
还有一种创建切片的方式，使用字面量，就是指定初始化的值。
		slice:=[]int{1,2,3,4,5}
有没有发现，和创建数组非常像，只不过不用指定[]中的值，这时候切片的长度和容量是相等的，并且会根据我们指定的字面量推导出来。当然我们也可以像数组一样，只初始化某个索引的值：
		slice :=[]int{4:1}
还是指定了第5个元素为1，其它元素都是默认值0.设时候切片的长度和容量也是一样的。这里再次强调一下切片和数组的微小差别：
		array:=[5]int[4:1}
		slice:=[]int{4:1}
切片还有`nil切片`和`空切片`，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，**nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。**
		//nil
		var nilSlice []int
		//空
		slice:=[]int{}
**nil切片表示不存在的切片，而空切片表示一个空集合，**它们各有用处。
切片另外一个用处比较多的创建是基于现有的数组或者切片创建
		slice := []int{1,2,3,4,5}
		slice1 := slice[:]
		slice2 := slice[0:]
		slice3 := slice[:5]
		
		fmt.Println(slice1)
		fmt.Println(slice2)
		fmt.Println(slice3)
基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，它表示以i索引开始，到j索引结束，截取原数组或者切片，创建而成的新切片，新切片的值包含原切片的i索引，但不包含j索引，对比java的话，发现string的substring方法很像。
		slice := []int{1,2,3,4,5}
		newSlice := slice[1:3]
		newSlice[0] = 10
		fmt.Println(slice)
		fmt.Println(newSlice)
这个例子证明了，**`新的切片和原切片公用的是一个底层数组`**，所以当修改的时候，底层数组的值就会被改动，所以原切片的值也改变了。当然对于基于数组的切片也一样。
我们基于原数组或者切片创建一个新的切片后，那么新的切片的大小和容量是多少呢？
		对于底层数组容量是k的切片slice[i:j]来说
		长度：j-i
		容量：k-i
go提供了内置的len和cap函数来计算切片的长度和容量
		slice := []int{1,2,3,4,5}
		newSlice := slice[1:3]
		fmt.Printf("newSlice长度:%d,容量:%d", len(newSlice), cap(newSlice))
## 3. 使用切片
使用切片，和使用数组一样，通过索引就可以获取切片对应元素的值，同样也可以修改对应元素的值。
		slice := []int{1,2,3,4,5}
		fmt.Println(slice[2])
		slice[2] = 10
		fmt.Println(slice[2])
**切片只能访问到其长度以内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长**
我们前面讲了，切片算是一个动态数组，所以它可以按需增长，我们使用内置`append`函数即可。append函数可以为一个切片追加一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，append函数都会帮我们自动处理。
		slice := []int{1,2,3,4,5}
		newSlice := slice[1:3]
		newSlice=append(newSlice,10)
		fmt.Println(newSlice)
		fmt.Println(slice)
		//output
		[2 3 10]
		[1 2 3 10 5]
例子中，通过append函数为新创建的切片newSlice，追加了一个元素10，我们发现打印的输出，原切片slice的第4个值也被改变了，变成了10.引起这种结果的原因是因为newSlice有可用的容量，不会创建新的切片来满足追加，所以直接在newSlice后追加了一个元素10，因为newSlice和slice切片公用一个底层数组，所以切片slice的对应元素值也被改变了。
**这里newSlice新追加的第三个元素，其实对应的是slice的第四个元素，所以这里追加其实是把底层数组的第四个元素修改为10，然后把newslice长度调整为3**
如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来数组的值复制到新底层数组里，再追加新值，这时候就不会影响原来的底层数组了。
**`所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，和原数组分离，就不会因为公用底层数组而引起奇怪的问题，因为公用数组的时候修改内容，会影响多个切片`**
append函数会智能的增长底层数组的容量，目前的算法是：容量小于1000，总是成倍的增长，一旦容量超过1000，增长因子设置为1.25，也就是说每次会增加25%的容量。
newSlice=append(newSlice,slice...)
通过`...`操作符号，把一个切片追加到另一个切片里。(...操作符会将slice打散成len(slice)长度的单个字符)
## 4. 迭代切片
切片是一个集合，我们可以使用for range循环来迭代它，打印其中的每个元素以及对应的索引。
		slice := []int{1,2,3,4,5}
		for i, v range slice{
		    fmt.Printf("索引：%d，值：%d\n", i, v)
		}
如果我们不想要索引，可以使用_来忽略它，这是go语言的用法，很多不需要的函数等返回值，都可以忽略。
		slice := []int{1,2,3,4,5}
		for _, v range slice {
		    fmt.Printf("值：%d\n", v)
		}
**`这里需要说明的是，range返回的是切片元素的复制，而不是元素的引用`**
## 5. 在函数间传递切片
我们知道切片是三个字段构成的结构类型，所以在函数间以值的方式传递的时候，占用的内存非常小，成本很低。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数据。
		func main(){
		    slice := []int{1,2,3,4,5}
		    fmt.Printf("%p\n", &slice)
		    modify(slice)
		    fmt.Println(slice)
		}
		
		func modify(slice []int) {
		    fmt.Printf("%p\n", &slice)
		    slice[1] = 10
		}
		//output
		0xc420082060
		0xc420082080
		[1 10 3 4 5]
仔细看，这两个切片的地址不一样，所以可以确认切片在函数间传递是复制的。而我们修改一个索引的值后，发现原切片的值也被修改了，说明它们公用一个底层数组。
在函数间传递切片非常高效，而且不需要传递指针和处理复杂的语法，只需要复制切片，然后根据自己的业务修改，最后传递回一个新的切片副本即可，这也是为什么函数间传递参数，使用切片，而不是数组原因。
