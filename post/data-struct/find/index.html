<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>[数据结构与算法 | 查找算法] - FaceDamon`s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Poll的笔记" /><meta name="description" content="转载自 https://www.cnblogs.com/maybe2030/p/4715035.html#_label0 摘要 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.81.0 with theme even" />


<link rel="canonical" href="http://facedamon.github.io/post/data-struct/find/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="[数据结构与算法 | 查找算法]" />
<meta property="og:description" content="转载自 https://www.cnblogs.com/maybe2030/p/4715035.html#_label0 摘要 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://facedamon.github.io/post/data-struct/find/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-13T15:54:56&#43;08:00" />
<meta property="article:modified_time" content="2021-01-13T15:54:56&#43;08:00" />

<meta itemprop="name" content="[数据结构与算法 | 查找算法]">
<meta itemprop="description" content="转载自 https://www.cnblogs.com/maybe2030/p/4715035.html#_label0 摘要 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介"><meta itemprop="datePublished" content="2021-01-13T15:54:56&#43;08:00" />
<meta itemprop="dateModified" content="2021-01-13T15:54:56&#43;08:00" />
<meta itemprop="wordCount" content="5249">
<meta itemprop="keywords" content="数据结构与算法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[数据结构与算法 | 查找算法]"/>
<meta name="twitter:description" content="转载自 https://www.cnblogs.com/maybe2030/p/4715035.html#_label0 摘要 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">FaceDamon</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about-me/">
        <li class="mobile-menu-item">About Me</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">FaceDamon</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about-me/">About Me</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">[数据结构与算法 | 查找算法]</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-01-13 </span>
        <div class="post-category">
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"> 数据结构与算法 </a>
            </div>
          <span class="more-meta"> 约 5249 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#顺序查找">顺序查找</a></li>
    <li><a href="#二分查找">二分查找</a></li>
    <li><a href="#插值查找">插值查找</a></li>
    <li><a href="#斐波那契查找">斐波那契查找</a></li>
    <li><a href="#二叉查找树">二叉查找树</a></li>
    <li><a href="#分块查找">分块查找</a>
      <ul>
        <li><a href="#特点">特点</a></li>
      </ul>
    </li>
    <li><a href="#哈希查找">哈希查找</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>转载自 <a href="https://www.cnblogs.com/maybe2030/p/4715035.html#_label0">https://www.cnblogs.com/maybe2030/p/4715035.html#_label0</a></p>
</blockquote>
<h1 id="摘要">摘要</h1>
<p>  查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p>
<ul>
<li>查找定义：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素</li>
<li>查找算法分类：</li>
</ul>
<ol>
<li>静态查找和动态查找(静态或动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表)</li>
<li>无序查找和有序查找
<ol>
<li>无序查找：被查找数列有序无序均可</li>
<li>有序查找：被查找数列必须为有序数列</li>
</ol>
</li>
</ol>
<ul>
<li>平均查找长度(Average Search Length, ASL): 由于所费时间在关键字的比较上，所以把平均需要和待查找值比较的关键字次数称为平均查找长度。</li>
</ul>
<p>$$
ASL=\sum_{i=1}^nP_iC_i
$$</p>
<p>  其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。</p>
<blockquote>
<p>一个算法的ASL越大，说明时间性能差，反之，时间性能好.</p>
</blockquote>
<h2 id="顺序查找">顺序查找</h2>
<ul>
<li>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</li>
<li>基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</li>
<li>复杂度分析
<ul>
<li>假设每个元素查找概率相同，$P_i=\frac1n$</li>
<li>Ci在于这个元素在查找表中的位置，如第0号元素就需要比较一次，第一号元素比较2次&hellip;&hellip;第n号元素要比较n+1次。所以Ci=i；所以</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/facedamon/markdownps2@master/collection/1539112-20190108133107514-1052426163.png" alt="avatar"></p>
<p>  可以看出，顺序查找方法查找成功的平均 比较次数约为表长的一半</p>
<p>  <strong>当待查找元素不在查找表中时，也就是扫描整个表都没有找到，即比较了n次，查找失败O(n)</strong></p>
<pre><code>// 顺序查找
int sequenceFind(int[] a, int value, int n) {
    if (a == null || a.length != n || n &lt; 1) {
        return -1;
    }
    if (n == 1 &amp;&amp; a[0] != value) {
        return -1;
    }
    for (int i = 0; i &lt; n; i++) {
        if (a[i] == value) {
            return i;
        }
    }
    return -1;
}
</code></pre>
<h2 id="二分查找">二分查找</h2>
<ul>
<li>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</li>
<li>基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</li>
<li>复杂度分析：<strong>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)</strong></li>
</ul>
<p>  注：折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<pre><code>// 二分查找
int binaryFind(int[] a, int value, int n) {
    if (a == null || a.length != n || n &lt; 1) {
        return -1;
    }
    if (n == 1 &amp;&amp; a[0] != value) {
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid;
    while (low &lt;= high) {
        mid = (low + high) &gt;&gt; 1;
        if (a[mid] == value) {
            return mid;
        }
        if (a[mid] &gt; value) {
            high = mid - 1;
        }
        if (a[mid] &lt; value) {
            low = mid + 1;
        }
    }
    return -1;
}

@Test
public void testBinaryFind() {
    int[] a = {1, 2, 3, 4, 5, 6};
    //int[] a = {};
    //int[] a = {1};
    //int[] a = {1,2};
    System.out.println(binaryFind(a, 3, a.length));
}

// 二分查找 递归
int binaryFindRev(int[] a, int value, int low, int high) {
    if (a == null || a.length &lt; 1) {
        return -1;
    }
    int mid = low + ((high - low) &gt;&gt; 1);
    if (a[mid] == value) {
        return mid;
    }
    if (mid &gt;= high) {
        return -1;
    }
    if (a[mid] &gt; value) {
        return binaryFindRev(a, value, low, mid - 1);
    }
    if (a[mid] &lt; value) {
        return binaryFindRev(a, value, mid + 1, high);
    }
    return -1;
}

@Test
public void testBinaryFindRev() {
    int[] a = {1, 2, 3, 4, 5, 6};
    //int[] a = {};
    //int[] a = {1};
    //int[] a = {1,2};
    System.out.println(binaryFindRev(a, 3, 0, a.length - 1));
}
</code></pre>
<h2 id="插值查找">插值查找</h2>
<p>  在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</p>
<p>  打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。</p>
<p>  同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</p>
<p>  经过以上分析，折半查找这种查找方式，<strong>不是自适应的（也就是说是傻瓜式的）</strong>。二分查找中查找点计算如下：</p>
<pre><code>                                        // offset
mid = (low + high) / 2; ==&gt; mid = low + 1/2 * (high - low);
</code></pre>
<p>  通过类比，我们可以将查找的点改进为如下：</p>
<pre><code>            // offset
mid = low + (key - a[low])/(a[high] - a[low]) * (high - low);
</code></pre>
<p>  也就是将上述的比例参数1/2改进为自适应的，<strong>根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key</strong>，这样也就间接地减少了比较次数。</p>
<p>  基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p>
<p>  <strong>注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p>
<ul>
<li>复杂度分析：<strong>查找成功或者失败的时间复杂度均为O(log2(log2n))。</strong></li>
</ul>
<!-- raw HTML omitted -->
<pre><code>int insertionFind(int[] a, int value, int n) {
    if (a == null || a.length != n || n &lt; 1) {
        return -1;
    }
    if (n == 1 &amp;&amp; a[0] != value) {
        return -1;
    }
    int low = 0;
    int high = n - 1;
    int mid = 0;
    while (low &lt;= high) {
        // 防止by zero 错误
        if (low == high) {
            if (a[low] == value) {
                return low;
            }
            return -1;
        }
        mid = low + (value - a[low])/(a[high] - a[low]) * (high - low);
        if (a[mid] == value) {
            return mid;
        }
        if (a[mid] &gt; value) {
            high = mid - 1;
        }
        if (a[mid] &lt; value) {
            low = mid + 1;
        }
    }
    return -1;
}

@Test
public void testInsertionFind() {
    int[] a = {1, 2, 3, 4, 5, 6};
    //int[] a = {};
    //int[] a = {1};
    //int[] a = {1,2,3};
    //int[] a = {1,2,4};
    System.out.println(insertionFind(a, 3, a.length));
}
</code></pre>
<h2 id="斐波那契查找">斐波那契查找</h2>
<p>  在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</p>
<p>  黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</p>
<p>  0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</p>
<p>  大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</p>
<ul>
<li>基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/facedamon/markdownps2@master/collection/20150323100632467.jpeg" alt="avatar"></p>
<p>  斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他<strong>要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1</strong>;</p>
<p>  开始将k值与第F(k-1)位置的记录比较,mid=low+F(k-1)+1,比较结果分为三种：</p>
<ol>
<li>相等，返回mid</li>
<li>大于，low=mid+1，k-=2；(说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。)</li>
<li>小于，high=mid-1,k-=1;(说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。)</li>
</ol>
<ul>
<li>复杂度分析：<strong>最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)</strong>。</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>// 斐波那契数组的长度
private static final int MAX_SIZE = 20;

// 构造一个斐波那契数组
int[] fibonacci() {
    int[] f = new int[MAX_SIZE];
    f[0] = 0;
    f[1] = 1;
    for (int i = 2; i &lt; MAX_SIZE; i++) {
        f[i] = f[i-1]+f[i-2];
    }
    return f;
}

// 斐波那契查找
int fibonacciFind(int a[], int value) {
    if (a == null || a.length &lt; 1) {
        return -1;
    }
    int low = 0;
    int high = a.length - 1;
    // fibonacci index
    int k = 0;
    int mid = 0;
    int[] f = fibonacci();
    while (f[k] - 1 &lt; a.length) {
        k++;
    }
    // 扩展到f[k]长度
    int[] temp = Arrays.copyOf(a, f[k]);
    // 扩展的空间复制最后一位的数字
    for (int i = high+1; i &lt; temp.length; i++) {
        temp[i] = a[high];
    }

    while (low &lt;= high) {
        mid = low + f[k-1]-1;
        if (temp[mid] &gt; value) {
            high = mid - 1;
            k--;
        } else if (temp[mid] &lt; value) {
            low = mid + 1;
            k-=2;
        } else {
            //查找值的下标在arr数组额范围内，直接返回
            if (mid &lt; a.length) {
                return mid;
            } else {
                //不在就返回right,为什么？因为后面几位的值和right的值是一样的，说明查找的值就是right
                return high;
            }
        }
    }
    return -1;
}

@Test
public void testFibonacciFind() {
    int[] a = {0,16,24,35,47,59,62,88,99};
    //int[] a = {0,16,24,35,47,59,62,88};
    //int[] a = {0,16};
    //int[] a = {0};
    //int[] a = {99};
    //int[] a = {};
    System.out.println(fibonacciFind(a, 99));
}
</code></pre>
<h2 id="二叉查找树">二叉查找树</h2>
<ul>
<li>
<p>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p>
</li>
<li>
<p>有关二叉查找树的详细说明，请移步<a href="http://facedamon.github.io/http://127.0.0.1:1313/post/data-struct/tree-struct/bstree/">二叉查找树</a></p>
</li>
<li>
<p>复杂度分析：<strong>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度</strong>。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p>
</li>
<li>
<p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>
</li>
</ul>
<h2 id="分块查找">分块查找</h2>
<p>  分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<ul>
<li>将n个数据元素&quot;按块有序&quot;划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须&quot;按块有序&quot;；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……</li>
<li>算法流程
<ul>
<li>先选取各块中的最大关键字构成一个索引表</li>
<li>查找分两个部分：先对索引表进行二分查找或者顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>private static class BlockFind {
    // 索引表
    private int[] index;
    // 块
    private ArrayList&lt;Integer&gt;[] lists;

    // 构建索引表
    public BlockFind(int[] index) {
        if (index != null &amp;&amp; index.length != 0) {
            this.index = index;
            this.lists = new ArrayList[index.length];
            for (int i = 0; i &lt; lists.length; i++) {
                lists[i] = new ArrayList&lt;Integer&gt;();
            }
        } else {
            throw new RuntimeException(&quot;index cannot be null or empty.&quot;);
        }
    }

    /**
     * 二分查找定位索引位置
     * @param data 要插入的值
     * @return
     */
    private int binaryFind(int data) {
        int low = 0;
        int high = index.length - 1;
        int mid = 0;
        while (low &lt;= high) {
            mid = (low + high) &gt;&gt; 1;
            if (index[mid] &gt; data) {
                high = mid - 1;
            } else {
                // 如果相等，也插入在后面
                low = mid + 1;
            }
        }
        return low;
    }

    // 打印每块元素
    public void printAll() {
        for (int i = 0; i &lt; lists.length; i++) {
            ArrayList list = lists[i];
            System.out.println(&quot;ArrayList &quot; + i + &quot;:&quot;);
            System.out.println(lists[i].toString());
        }
    }

    // 插入元素
    public void insert(int value) {
        int i = binaryFind(value);
        lists[i].add(value);
    }

    // 查找元素
    public String find(int data) {
        int i = binaryFind(data);
        for (int j = 0; j &lt; lists[i].size(); j++) {
            if (data == lists[i].get(j)) {
                return String.format(&quot;在第%d块，第%d个&quot;,i+1, j+1);
            }
        }
        return String.format(&quot;%d 不存在&quot;, data);
    }
}

@Test
public void testBlockFind() {
    int[] index = {10, 20, 30};
    BlockFind blockFind = new BlockFind(index);
    blockFind.insert(1);
    blockFind.insert(12);
    blockFind.insert(22);

    blockFind.insert(9);
    blockFind.insert(18);
    blockFind.insert(23);

    blockFind.insert(5);
    blockFind.insert(15);
    blockFind.insert(27);

    blockFind.printAll();

    System.out.println(blockFind.find(18));
    System.out.println(blockFind.find(29));
}
</code></pre>
<h3 id="特点">特点</h3>
<p>  分块查找的特点其实显而易见，那就是分块查找拥有顺序查找和二分查找的双重优势，即顺序查找不需要有序，二分查找的速度快。</p>
<p>  分块查找由于只需要索引表有序，所以特别适合用于在动态变化的数据元素序列中查找。但是如何分块比较复杂。如果分块过于稀疏，则可能导致每一块的内容过多，在顺序查找时效率很低；如果分块过密，则又会导致块数很多，无论是插入还是删除数据，都会频繁地进行二分查找；如果块数特别多，则基本上和直接二分查找的动态插入数据类似，这样分块查找就没有意义了。</p>
<p>  所以对于分块查找来说，可以根据数据量的大小及数据的区间来进行对分块的选择。二分查找的平均查找长度近似 log2(n+1)-1，这里的n是块数；顺序查找的平均查找长度为 (n+1)/2，这里的 n 是每块的个数。</p>
<p>  尽量等分为固定的块，假设块数为 a，每个块内的元素数量为 b，则 b=n/a，那么接下来就好办了，如果给定一个数据量 n 进行分块，则总的平均查找长度为 (b+1)/2+log2(a+1)-1，这样就可以解出 a 和 b 分别为多少了。</p>
<h2 id="哈希查找">哈希查找</h2>
<ul>
<li>什么是哈希表（Hash）？</li>
</ul>
<p>  我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素&quot;分类&quot;，然后将这个元素存储在相应&quot;类&quot;所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了&quot;冲突&quot;，换句话说，就是把不同的元素分在了相同的&quot;类&quot;之中。后面我们将看到一种解决&quot;冲突&quot;的简便做法。</p>
<blockquote>
<p>总的来说，&ldquo;直接定址&quot;与&quot;解决冲突&quot;是哈希表的两大特点。</p>
</blockquote>
<ul>
<li>什么是哈希函数</li>
</ul>
<p>  哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。</p>
<ul>
<li>算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</li>
<li>算法流程
<ul>
<li>用给定的哈希函数构造哈希表；</li>
<li>根据选择的冲突处理方法解决地址冲突；</li>
<li>在哈希表的基础上执行哈希查找。</li>
</ul>
</li>
<li>复杂度分析
<ul>
<li>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</li>
</ul>
</li>
</ul>
<p>  有关哈希表的详细说明，请移步<a href="http://facedamon.github.io/post/data-struct/hash/">散列表</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Poll的笔记</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-01-13
        
    </span>
  </p>
  <p class="copyright-item">
      <span class="item-title">原始文档</span>
      <span class="item-content"><a class="link-to-markdown" href="http://facedamon.github.io/post/data-struct/find/index.md" target="_blank">查看本文 Markdown 版本 »</a></span>
    </p>
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://www.gnu.org/licenses/gpl-3.0.html" target="_self"><img src="https://img.shields.io/badge/license-GPL-blue.svg?style=flat-square)"></img></a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/data-struct/sort/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[数据结构与算法 | 排序算法]</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/java/collection/treemap/">
            <span class="next-text nav-default">[Java | TreeMap]</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:facedamon@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/facedamon" class="iconfont icon-github" title="github"></a>
  <a href="http://facedamon.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">FaceDamon</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">

<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: {equationNumbers: {autoNumber: "AMS"}},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
