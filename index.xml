<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/</link>
    <description>Recent content on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 01 Apr 2021 14:25:56 +0800</lastBuildDate><atom:link href="http://facedamon.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About Me</title>
      <link>http://facedamon.github.io/about-me/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://facedamon.github.io/about-me/</guid>
      <description>何许人也 FaceDamon，真名嘛？肯定是假的啦！小时候村里村外都晓得我，为啥？因为我是个名副其实的野孩子。生在富平，长在富平，却落在成都。</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构 | 装饰器模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 01 Apr 2021 14:25:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构 | 享元模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 22 Mar 2021 15:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提</description>
    </item>
    
    <item>
      <title>[设计模式 | 外观 | 模板模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 22 Mar 2021 15:06:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构 | 外观模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 15:35:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，</description>
    </item>
    
    <item>
      <title>[mybatis源码(二) | 核心组件]</title>
      <link>http://facedamon.github.io/post/java/mybatis/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 20 Mar 2021 15:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/mybatis/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>摘要 SqlSession是MyBatis提供的面向用户的操作数据库API。那么MyBatis底层是如何工作的呢？为了解开MyBatis的神秘</description>
    </item>
    
    <item>
      <title>[设计模式 | 结构 | 代理模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 11:11:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E7%BB%93%E6%9E%84/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象</description>
    </item>
    
    <item>
      <title>[mybatis源码(一) | 工具类]</title>
      <link>http://facedamon.github.io/post/java/mybatis/%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Fri, 19 Mar 2021 11:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/mybatis/%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>工具类 SQL构造器 为了解决代码中sql拼接问题，mybatis中提供了一个sql工具类。使用这个工具类，我们可以很方便地在Java代码中动态</description>
    </item>
    
    <item>
      <title>[Java | 生产消费问题]</title>
      <link>http://facedamon.github.io/post/java/thread/4.producer/</link>
      <pubDate>Thu, 21 Jan 2021 18:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/4.producer/</guid>
      <description>模型 生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下： 生产者仅仅在仓</description>
    </item>
    
    <item>
      <title>[Java | 线程等待于唤醒]</title>
      <link>http://facedamon.github.io/post/java/thread/3.wait/</link>
      <pubDate>Thu, 21 Jan 2021 15:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/3.wait/</guid>
      <description>摘要 在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状</description>
    </item>
    
    <item>
      <title>[Java | synchronized]</title>
      <link>http://facedamon.github.io/post/java/thread/2.synchronized/</link>
      <pubDate>Wed, 20 Jan 2021 21:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/2.synchronized/</guid>
      <description>原理 在Java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在的 当我们调用某个对象的synchronized方法时，就</description>
    </item>
    
    <item>
      <title>[Java | 多线程基本概念]</title>
      <link>http://facedamon.github.io/post/java/thread/1.gainian/</link>
      <pubDate>Wed, 20 Jan 2021 20:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/1.gainian/</guid>
      <description>摘要 多线程是Java中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对“JDK中新增JUC包”之前的Java</description>
    </item>
    
    <item>
      <title>[Java | 抽象类与接口]</title>
      <link>http://facedamon.github.io/post/java/base/4.abstract-interface/</link>
      <pubDate>Tue, 19 Jan 2021 17:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/4.abstract-interface/</guid>
      <description>摘要 抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之多态]</title>
      <link>http://facedamon.github.io/post/java/base/3.duotai/</link>
      <pubDate>Tue, 19 Jan 2021 15:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/3.duotai/</guid>
      <description>摘要 面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之继承]</title>
      <link>http://facedamon.github.io/post/java/base/2.extends/</link>
      <pubDate>Sun, 17 Jan 2021 17:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/2.extends/</guid>
      <description>摘要 在《Thinnk in Java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但是要想成为极具革命性的语言，仅仅能够复制代码并对</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之封装]</title>
      <link>http://facedamon.github.io/post/java/base/1.fengzhuang/</link>
      <pubDate>Sun, 17 Jan 2021 17:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/1.fengzhuang/</guid>
      <description>摘要 封装从字面上来理解就是包装的意思，就是隐藏信息，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 排序算法]</title>
      <link>http://facedamon.github.io/post/data-struct/sort/</link>
      <pubDate>Wed, 13 Jan 2021 20:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/sort/</guid>
      <description>摘要 排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”记录。分内部排序和外部排序。 若整个排序过程不需要访问外存</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 查找算法]</title>
      <link>http://facedamon.github.io/post/data-struct/find/</link>
      <pubDate>Wed, 13 Jan 2021 15:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/find/</guid>
      <description>转载自 https://www.cnblogs.com/maybe2030/p/4715035.html#_label0 摘要 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介</description>
    </item>
    
    <item>
      <title>[Java | TreeMap]</title>
      <link>http://facedamon.github.io/post/java/collection/treemap/</link>
      <pubDate>Mon, 11 Jan 2021 16:26:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/treemap/</guid>
      <description>摘要 之前的文章讲解了两种Map，分别是HashMap与LinkedHashMap，它们保证了以O(1)的时间复杂度进行增、删、改、查，从存储</description>
    </item>
    
    <item>
      <title>[Java | LinkedHashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/linkedhashmap/</link>
      <pubDate>Mon, 11 Jan 2021 14:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/linkedhashmap/</guid>
      <description>摘要 大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不</description>
    </item>
    
    <item>
      <title>[Java | ConcurrentHashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/concurrenthashmap/</link>
      <pubDate>Sat, 09 Jan 2021 18:11:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/concurrenthashmap/</guid>
      <description>背景 线程不安全的HashMap 因为多线程环境下，使用HashMap扩容操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使</description>
    </item>
    
    <item>
      <title>[Java | HashMap引发死循环]</title>
      <link>http://facedamon.github.io/post/java/collection/hashmaprehash/</link>
      <pubDate>Sat, 09 Jan 2021 15:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/hashmaprehash/</guid>
      <description>摘要 上一篇文章了解了HashMap的实现原理，讲到了HashMap不是线程安全的。那么HashMap在多线程环境下又会有什么问题呢？先来看一</description>
    </item>
    
    <item>
      <title>[Java | HashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/hashmap/</link>
      <pubDate>Fri, 08 Jan 2021 16:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/hashmap/</guid>
      <description>摘要 对于集合，我认为关注的点主要有四点： 关注点 结论 HashMap是否允许null Key和Value都允许为空 HashMap是否允许重复数据 K</description>
    </item>
    
    <item>
      <title>[Java | LinkedList]</title>
      <link>http://facedamon.github.io/post/java/collection/linkedlist/</link>
      <pubDate>Thu, 07 Jan 2021 19:10:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/linkedlist/</guid>
      <description>摘要 LinkedList是基于链表实现的，所以先讲解一下什么是链表。链表原先是C/C++的概念，是一种线性的存储结构，意思是将要存储的数据存</description>
    </item>
    
    <item>
      <title>[Java | CopyOnWriteArrayList]</title>
      <link>http://facedamon.github.io/post/java/collection/copyonwritearraylist/</link>
      <pubDate>Thu, 07 Jan 2021 18:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/copyonwritearraylist/</guid>
      <description>摘要 CopyOnWriteArrayList位于java.util.concurrent包下，可想而知，这个类是为并发而设计的。 CopyOn</description>
    </item>
    
    <item>
      <title>[Java | ArrayList]</title>
      <link>http://facedamon.github.io/post/java/collection/arraylist/</link>
      <pubDate>Thu, 07 Jan 2021 18:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/arraylist/</guid>
      <description>摘要 对于集合，我认为关注的点主要有四点： 关注点 结论 ArrayList是否允许null 允许 ArrayList是否允许重复数据 允许 ArrayLi</description>
    </item>
    
    <item>
      <title>[Java | 集合框架概述]</title>
      <link>http://facedamon.github.io/post/java/collection/%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 06 Jan 2021 18:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/%E6%9E%B6%E6%9E%84/</guid>
      <description>集合框架图 所有集合类都位于java.util包下。Java集合类主要由两个接口派生：Collection和Map，Collection和Ma</description>
    </item>
    
    <item>
      <title>[Java | 乐观锁与悲观锁]</title>
      <link>http://facedamon.github.io/post/java/thread/sync/</link>
      <pubDate>Sat, 02 Jan 2021 17:28:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/sync/</guid>
      <description>摘要 乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 散列表基本原理]</title>
      <link>http://facedamon.github.io/post/data-struct/hash/</link>
      <pubDate>Sat, 02 Jan 2021 14:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/hash/</guid>
      <description>摘要 符号表是一种用于存储键值对（key-value pair）的数据结构，我们平常经常使用的数组也可以看做是一个特殊的符号表，数组中的“键”即</description>
    </item>
    
    <item>
      <title>[大型网站技术架构 | 漏桶算法与令牌桶算法]</title>
      <link>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 30 Dec 2020 16:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</guid>
      <description>转载自 https://www.cnblogs.com/xuwc/p/9123078.html 问题描述 某天A君突然发现自己的接口请求量突然涨到之前的10倍，没多久该接口几乎不可使用，并引发连锁反应导致整个系统崩溃。如何应对这种</description>
    </item>
    
    <item>
      <title>[Java | 什么是线程安全]</title>
      <link>http://facedamon.github.io/post/java/thread/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
      <pubDate>Thu, 24 Dec 2020 16:25:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
      <description>转载自 https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html 不是线程的安全 面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。 论语中有句叫“学而优则仕”，相信很多人都觉得是“学</description>
    </item>
    
    <item>
      <title>[分布式ID生成策略]</title>
      <link>http://facedamon.github.io/post/uid/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sat, 14 Nov 2020 11:29:55 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/uid/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</guid>
      <description>美团 背景 在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 原型模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 30 Oct 2020 14:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 原型模式(Propertype Pattern)是用于创建重复的对象，同时又能保证性能。 这种模式是实现了一个原型接口，该接口用于创建当前对</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 建造者模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 27 Oct 2020 17:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 Builder Pattern使用多个简单的对象一步一步构建一个复杂的对象。 介绍 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的</description>
    </item>
    
    <item>
      <title>[分布式缓存 (七) | Protobuf]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</link>
      <pubDate>Wed, 21 Oct 2020 15:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</guid>
      <description>为什么要使用protobuf protobuf既Protocol Buffers, Google开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语</description>
    </item>
    
    <item>
      <title>[分布式缓存 (六) | 防止缓存击穿]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</link>
      <pubDate>Wed, 21 Oct 2020 10:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</guid>
      <description>摘要 缓存雪崩：缓存在同一时刻全部失效，造成瞬间DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的key设置了相同的过期</description>
    </item>
    
    <item>
      <title>[分布式缓存 (五) | 分布式节点]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 20 Oct 2020 10:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</guid>
      <description>流程回顾 接收key --&amp;gt; 检查是否被缓存 ---是---&amp;gt; 返回缓存值(1) |否 |------&amp;gt;是否应当从远程节点获取 ------&amp;gt; 与远程节点交互 ---&amp;gt; 返</description>
    </item>
    
    <item>
      <title>[分布式缓存 (四) | 一致性HASH]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</link>
      <pubDate>Mon, 19 Oct 2020 09:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</guid>
      <description>摘要 今天我们要实现的是一致性哈希算法，一致性哈希算法是Geec从单节点走向分布式节点的一个重要的环节。 我该访问谁 对于分布式缓存来说，当一个节</description>
    </item>
    
    <item>
      <title>[微服务设计 | SaaS]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/saas/</link>
      <pubDate>Fri, 25 Sep 2020 09:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/saas/</guid>
      <description>摘要 SaaS区别于其他应用程序的主要特征就是能够使客户在使用应用程序时按照使用量付费。他们不需要为软件购买许可，也不需要安装、托管和管理它。</description>
    </item>
    
    <item>
      <title>[微服务设计 | 分布式事务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 17 Sep 2020 10:17:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>转载自 https://juejin.im/post/6844903734753886216 作者 caison@aliyun.com 摘要 这篇文章主要介绍什么是分布式事务，分布式事务解决什么问题，对分布式事务实现的难点，解决思路，不同场景下的选择，通过图解的方</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 单例模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 单例模式(Singleton Pattern) 是Java中最简单的设计模式之一。它提供了一种创建对象的最佳方法。 这种模式涉及到一个单一的类，该类负责创建</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 抽象工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 15:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 抽象工厂模式(Abstract Factory Pattern)用于生成产品族的工厂。该工厂又称为其它工厂的工厂。在抽象工厂模式中，接口是负责创建一个相</description>
    </item>
    
    <item>
      <title>[设计模式 | 创建 | 工厂模式]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 10 Sep 2020 14:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E5%88%9B%E5%BB%BA/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>摘要 工厂模式(Factory Pattern)是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方</description>
    </item>
    
    <item>
      <title>[设计模式 | 行为 | 观察者模式实践之电商业务]</title>
      <link>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 02 Sep 2020 11:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/design-patterns/%E8%A1%8C%E4%B8%BA/%E8%A7%82%E5%AF%9F%E8%80%85%E5%AE%9E%E8%B7%B5/</guid>
      <description>什么是观察者模式 观察者观察被观察者，被观察者通知观察者 我们用&amp;quot;订阅通知&amp;quot;翻译下[观察者模式]的概念： &amp;ldquo;订阅者</description>
    </item>
    
    <item>
      <title>[Redis | 进阶]</title>
      <link>http://facedamon.github.io/post/redis/%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 31 Aug 2020 16:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E8%BF%9B%E9%98%B6/</guid>
      <description>事务 在微博中，用户之间是&amp;quot;关注&amp;quot;和&amp;quot;被关注&amp;quot;的关系。如果要使用Redis存储这样的关系可以使用集合类</description>
    </item>
    
    <item>
      <title>[微服务设计(三) | 集成技术]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/3.-%E9%9B%86%E6%88%90/</link>
      <pubDate>Mon, 24 Aug 2020 16:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/3.-%E9%9B%86%E6%88%90/</guid>
      <description>摘要 微服务之间通信方式的选择非常多样化，但哪个是正确的呢？SOAP? XML-RPC? REST? Protocol Buffers? 后面会逐一讨论，在此之前需要考虑的是，我们到底希望从这些技术中得</description>
    </item>
    
    <item>
      <title>[Redis | 基础]</title>
      <link>http://facedamon.github.io/post/redis/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 14 Aug 2020 10:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</guid>
      <description>基础类型 string list hash set zset string 一个字符串类型允许存储的数据的最大容量是512MB。 command return set key value 返回ok get key 当key不存在是返回empty incr key 返回递增后的</description>
    </item>
    
    <item>
      <title>[Redis | 缓存更新策略]</title>
      <link>http://facedamon.github.io/post/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 13 Aug 2020 14:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</guid>
      <description>转载自 https://coolshell.cn/articles/17416.html 问题引入 很多人在写更新缓存数据代码时，先删除缓存，然后再更新数据库，而后续的操作会把数据再装载到缓存中。这是有问题的。 假设，一个更新</description>
    </item>
    
    <item>
      <title>[Redis | 分布式集群环境搭建]</title>
      <link>http://facedamon.github.io/post/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 12 Aug 2020 09:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%90%AD%E5%BB%BA/</guid>
      <description>转载自 https://www.cnblogs.com/esofar/p/10486621.html 摘要 Redis Cluster 即 Redis 集群，是 Redis 官方在 3.0 版本推出的一套分布式存储方案。完全去中心化，由多个节点组成，所有节点彼此互联。Redis 客户端可以直接</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 前缀树(敏感词过滤)]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/trie/</link>
      <pubDate>Tue, 28 Jul 2020 16:26:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/trie/</guid>
      <description>摘要 前缀树，又称字典树。之前在手写http框架(路由)中已经略有介绍。这次我们专门做一个关于前缀树的详细介绍及应用。 前缀树主要应用于统计，排</description>
    </item>
    
    <item>
      <title>[分布式缓存 (三) | HTTP]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</link>
      <pubDate>Fri, 24 Jul 2020 16:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</guid>
      <description>摘要 分布式缓存需要实现节点间通信，建立基于HTTP的通信机制是比较常见的做法。如果一个节点启动了HTTP服务， 那么这个节点就可以被其它节点访</description>
    </item>
    
    <item>
      <title>[分布式缓存 (二) | 确保一致性]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</link>
      <pubDate>Mon, 20 Jul 2020 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</guid>
      <description>摘要 在上一篇博客中，我们实现了LRU缓存淘汰策略。接下来我们使用sync.RWMutex封装LRU的几个方法，使之支持并发的读写。(对于并发</description>
    </item>
    
    <item>
      <title>[分布式缓存 (一) | LRU 淘汰策略]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</link>
      <pubDate>Mon, 20 Jul 2020 10:32:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</guid>
      <description>淘汰算法简介 geec的缓存全部存储在内存中，内存是有限的，因此不可能无限制添加数据。假定，我们设置缓存能够使用的内存大小为N,那么在某一个时</description>
    </item>
    
    <item>
      <title>[谈谈分布式缓存 (零) | golang cache]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 20 Jul 2020 09:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
      <description>摘要 第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。我想这是大部分人对于缓存的理解。在计算机系统中，缓存无处不</description>
    </item>
    
    <item>
      <title>[手写http框架 (六) | golang recover]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</link>
      <pubDate>Fri, 17 Jul 2020 09:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</guid>
      <description>摘要 在go中，比较常见的错误处理方式是返回error，由调用者巨顶后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在</description>
    </item>
    
    <item>
      <title>[手写http框架 (五) | golang middleware]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</link>
      <pubDate>Thu, 16 Jul 2020 10:30:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</guid>
      <description>摘要 中间件(middleware)，简单的说，就是非业务的技术类组件。http框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此</description>
    </item>
    
    <item>
      <title>[手写http框架 (四) | golang group]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</link>
      <pubDate>Thu, 16 Jul 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</guid>
      <description>摘要 分组控制是http框架提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景</description>
    </item>
    
    <item>
      <title>[手写http框架 (三) | golang router]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</link>
      <pubDate>Tue, 14 Jul 2020 16:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</guid>
      <description>摘要 使用trie树实现动态路由解析 支持两种模式:name和*filepath trie树 上一节，我们用了一个非常简单的map结果来存储了路由表</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (二)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</link>
      <pubDate>Fri, 03 Jul 2020 15:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%BA%8C/</guid>
      <description>参见 https://yunlzheng.gitbook.io/prometheus-book/</description>
    </item>
    
    <item>
      <title>[系统监控 | Prometheus (一)]</title>
      <link>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</link>
      <pubDate>Fri, 03 Jul 2020 11:03:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/promethues/prometheus%E4%B8%80/</guid>
      <description>摘要 由于该系统涉及较多的概念和技术，为了快速上手，第一篇文档主要讲解环境搭建。后期系列文档会逐一解释每一个关键的结点。 系统架构 简略解释 Pro</description>
    </item>
    
    <item>
      <title>[手写http框架 (二) | golang context]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</link>
      <pubDate>Wed, 24 Jun 2020 11:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</guid>
      <description>摘要 将路由router独立出来，方便之后增强。 设计上下文context，封装Request和Response，提供对JSON、HTML等返回</description>
    </item>
    
    <item>
      <title>[手写http框架 (一) | golang http-handler]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</link>
      <pubDate>Tue, 23 Jun 2020 15:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</guid>
      <description>摘要 简单介绍net/http库以及http.Handler接口 搭建Gee框架的雏形 标准库启动Web服务 Go语言内置了net/http库，封装</description>
    </item>
    
    <item>
      <title>[HTTP | golang net/http 源码解读]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Jun 2020 10:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>重要接口 接口名称 简略含义 Handler 处理请求接口 ResponseWriter 返回响应接口 ServeMux 路由 Conn tcp连接 Handler type Handler interface { ServeHTTP(ResponseWriter, *Request) } Handler接口是一个逻辑接口，所有的请求都会进入该</description>
    </item>
    
    <item>
      <title>[mongodb (一) | 基本操作]</title>
      <link>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 09 Jun 2020 09:09:42 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/mongodb/1.-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>基本操作 创建document #use dbname use chapter; 删除document #db.dropDatabase() use chapter; db.dropDatabase() 创建collection #db.createCollection(name, options) # example 集合空间大小614299KB,文档最大个数为</description>
    </item>
    
    <item>
      <title>[工程师学习方法]</title>
      <link>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 02 Jun 2020 14:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
      <description>环境 一名工程师在萌芽之中，特别容易自我劝退，偏安一隅。他们有一点解决自己温饱的技术，有一份较为稳定的工作，但他们态度恶劣，从来不学习如何学习</description>
    </item>
    
    <item>
      <title>[杂谈 | golang接口型函数]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 May 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</guid>
      <description>转载自 https://www.flysnow.org/2016/12/30/golang-function-interface.html 简介 接口型函数，指的是用函数实现接口，这样在调用的时候就会非常简便，这种方式使用于只有一个函数的接口。 原始接口 我们以迭代一个map为</description>
    </item>
    
    <item>
      <title>[杂谈 | golang database/sql使用]</title>
      <link>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</guid>
      <description>转载自 https://segmentfault.com/a/1190000003036452 概述 sql.DB不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 川西小环线]</title>
      <link>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</link>
      <pubDate>Fri, 01 May 2020 14:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/2.%E5%B7%9D%E8%A5%BF%E5%B0%8F%E7%8E%AF%E7%BA%BF/</guid>
      <description>前言 **2019年国庆是一个值得纪念的日子。**这是我第一次长途旅行，这次我放弃了贴吧寻找驴友，上面人多眼杂。几经转折后，相中了8264户外</description>
    </item>
    
    <item>
      <title>[Git (四) | 分支管理(案例驱动)]</title>
      <link>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 30 Apr 2020 09:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/4.-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</guid>
      <description>摘要 案例，实际工作中你会用到类似的流程。 开发某个网站 为实现某个新的需求，创建分支 在该分支上开展工作 正在此时，你接到通知，有一个很严重的bug</description>
    </item>
    
    <item>
      <title>[Git (三) | 分支原理]</title>
      <link>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 29 Apr 2020 16:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/3.-git%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</guid>
      <description>摘要 之所以要将Git分支原理单独讲解，主要是想好好理解一下Git的分支模型，这对以后的分支管理学习大有裨益。 简介 为了真正理解Git处理分支的</description>
    </item>
    
    <item>
      <title>[Git (二) | 上手]</title>
      <link>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Mon, 27 Apr 2020 10:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/2.-git%E4%B8%8A%E6%89%8B/</guid>
      <description>概要 希望通过这一节学习，能够**快速**掌握配置初始化仓库(repository)、开始或停止跟踪(track)文件、暂存(stage)、提</description>
    </item>
    
    <item>
      <title>[Git (一) | 三种状态和基础配置]</title>
      <link>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 27 Apr 2020 09:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/git/1.-git%E7%8A%B6%E6%80%81%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</guid>
      <description>三种状态 Git有三种状态：已提交(committed), 已修改(modified), 已暂存(staged)。已提交表示数据已经安全的保存在本</description>
    </item>
    
    <item>
      <title>[生活 | 旅游 | 牛背山]</title>
      <link>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</link>
      <pubDate>Sat, 25 Apr 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/life/travel/1.%E7%89%9B%E8%83%8C%E5%B1%B1/</guid>
      <description>四川牛背山之旅 前言 依稀记得，在2019年元旦时，初来成都，除了工作上的同事，自己没有几个耍得来的要好朋友。一次偶然的机会，在冲浪成都豆瓣时，</description>
    </item>
    
    <item>
      <title>[nginx (一) | nginx准备]</title>
      <link>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 16 Apr 2020 14:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/nginx/1.nginx%E5%9F%BA%E7%A1%80/</guid>
      <description>准备环境 首先需要一个内核为Linux 2.6及以上版本的操作系统，因为Linux 2.6及以上内核才支持epoll。在linux上使用selec</description>
    </item>
    
    <item>
      <title>[微服务设计(二) | 如何建模服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 13 Apr 2020 09:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/2.-%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 同过上节的讨论，我们已经知道什么是微服务了，你可能已经迫不及待地想要实现它了。但是从何做起呢？在本节中，我们会讨论如何确定服务之间的边界</description>
    </item>
    
    <item>
      <title>[微服务设计(一) | 微服务]</title>
      <link>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sun, 12 Apr 2020 13:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/1.-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>摘要 随着领域驱动设计、持续交付、按需虚拟化、基础设施自动化、小型自治团队、大型集群系统、模块化的流行，微服务也应运而生。它并不是被发明出来的</description>
    </item>
    
    <item>
      <title>[golang base(十一) | 分布式网络爬虫]</title>
      <link>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 06 Mar 2020 17:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>原因 有一定的复杂性 可以灵活调整项目的复杂性 平衡语言/爬虫之间的比重 爬虫分类 通用爬虫，如baidu，google 聚焦爬虫，从互联网获取结构化数</description>
    </item>
    
    <item>
      <title>[golang base(十) | 广度优先搜索]</title>
      <link>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 05 Mar 2020 15:29:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
      <description>广度优先算法 为爬虫实战做好准备 应用广泛，综合性强 面试常见 上图中是一个6*5的迷宫，0 代表可以走，1 代表墙，从左上角进右下角出，只能上左下右，</description>
    </item>
    
    <item>
      <title>[golang base(九) | 标准库]</title>
      <link>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Thu, 05 Mar 2020 14:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>http 使用http客户端发送请求 使用http.Client控制请求头部等 使用httputil简化工作 package main func main(){ // 访问手机版imooc r, err := http.NewRequest(http.MethodGet, &amp;quot;http://www.imooc.com&amp;quot;, nil) r.Header.Add(&amp;quot;User-Agent&amp;quot;,</description>
    </item>
    
    <item>
      <title>[golang base(八) | 再谈channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.channel/</link>
      <pubDate>Wed, 04 Mar 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.channel/</guid>
      <description>转载自 https://www.cnblogs.com/sparkdev/ 转载自 https://go-zh.org/ref/mem golang官网内存模型分析 转载自 https://taohuawu.club/high-performance-implementation-of-goroutine-pool 忠告 程序在修改被多个Go程同时访问的数据时必须序列化该访问。要序列化访问，需要通过Cha</description>
    </item>
    
    <item>
      <title>[golang base(八) | goroutine &amp; channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.-goroutine/</link>
      <pubDate>Wed, 04 Mar 2020 20:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.-goroutine/</guid>
      <description>goroutine package main func main() { for i := 0; i &amp;lt; 10; i++ { go func(i int){ for { fmt.Printf(&amp;quot;Hello from goroutine %d\n&amp;quot;, i) } }(i) } time.Sleep(time.Millisecond) } 如果不加go关键字的话，就是外循环进来一次一直执行匿名函数，不会退出。加了go关</description>
    </item>
    
    <item>
      <title>[golang base(七) | 测试与性能调优]</title>
      <link>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Sun, 01 Mar 2020 13:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>Debugging Sucks and Testing Rocks 测试 传统测试 VS 表格驱动测试 传统测试 @Test public void testAdd() { assertEquals(3, add(1, 2)); assertEquals(Integer.MIN_VALUE, add(1, Integer.MAX_VALUE)); } 测试数据和测试逻辑混在一起 出错信息不明确 一旦一个数据出错测试全部结束 表格</description>
    </item>
    
    <item>
      <title>[golang base(六) | 错误处理]</title>
      <link>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 28 Feb 2020 17:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>资源管理与出错处理 defer调用 确保在函数结束时调用 package main func tryDefer() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(&amp;quot;error occurr&amp;quot;) //触发return fmt.Println(4) } func writeFile(filename string) { file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, 0666) if err != nil { panic(err) } defer file.Close() writer</description>
    </item>
    
    <item>
      <title>[golang base(五) | 函数式编程]</title>
      <link>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 28 Feb 2020 17:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 函数式编程 VS 函数指针 函数是一等公民：参数，变量，返回值都可以是函数 闭包 package main func adder() func(int) int { sum := 0 // 自由变量 return func (v int) int { sum += v //v 局部变量 return</description>
    </item>
    
    <item>
      <title>[golang base(四) | 面向接口]</title>
      <link>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 28 Feb 2020 17:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口 duck typing 大黄鸭是不是一个鸭子? 传统类型系统：脊索动物，脊椎动物亚门，鸟纲雁形目。。。:no duck typing :yes，像鸭子走路，像鸭子叫，那么就是鸭子 描</description>
    </item>
    
    <item>
      <title>[golang base(三) | 面向对象]</title>
      <link>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 28 Feb 2020 17:07:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>结构体和方法 golang仅支持封装，不支持继承和多态 golang没有class，只有struct golang结构体没有构造方法这一说法 type treeNode struct</description>
    </item>
    
    <item>
      <title>[golang base(二) | 内建容器]</title>
      <link>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 28 Feb 2020 15:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</guid>
      <description>数组 数量写在类型的前面 func main() { // var 需要确定大小，可以不用初始化赋值 var arr1 [5]int // 简化，需要确定大小，需要初始化赋值 arr2 := [3]int{1, 3, 5} // ... 编译器根据初始化赋值</description>
    </item>
    
    <item>
      <title>[golang base(一) | 基础语法]</title>
      <link>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 28 Feb 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>变量定义 在golang中变量名在前变量类型在后 这样设计的初衷是什么?我们回想一下使用其它语言的变量的时候是先想到变量的名字还是先想到变量类型</description>
    </item>
    
    <item>
      <title>[杂谈 | golang设计哲学 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link>
      <pubDate>Thu, 02 Jan 2020 14:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid>
      <description>世界是并行的 先不说宇宙，就整个地球来说，世界万物都是并行发生的；天生对并发支持良好的go语言更容易描述并行的世界。 #世界是由物质组合构成的 微</description>
    </item>
    
    <item>
      <title>[杂谈 | golang发现序列]</title>
      <link>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 02 Jan 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</guid>
      <description>发现了一个好用的golang sql package sqlx，有点类似与java中的dbutils，可以实现结果集的自动映射 sqlx它没有传统ORM的繁琐，毕竟</description>
    </item>
    
    <item>
      <title>[杂谈 | golang是值传递 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 02 Jan 2020 12:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>什么是值传递 值传递的意思是：函数传递总是原来这个东西的一个副本，一幅拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 二叉查找树]</title>
      <link>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</link>
      <pubDate>Thu, 07 Nov 2019 17:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/tree-struct/bstree/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 转载《算法导论》 转载 https://github.com/emirpasic/gods 概要 本节先对二叉树的相关理论知识进行介绍，然后给出Java的详细实现。关于二叉树的学习，需要说明的是：它并不难</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 队列]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 05 Nov 2019 17:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E9%98%9F%E5%88%97/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 本节介绍队列的基本原理，然后分别给出队列的Java、Golang两种语言的实现。 队列的介绍 队列是一种线性存储结构。它有以下特点：</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 栈 ]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</link>
      <pubDate>Tue, 05 Nov 2019 10:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%A0%88/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 本节会现对栈的原理进行介绍，然后分别通过Java/Golang三种语言来演示栈的实现示例。 栈的介绍 栈是一种线性存储结构，它有以下</description>
    </item>
    
    <item>
      <title>[数据结构与算法 | 数组、单链表、双向链表]</title>
      <link>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 24 Oct 2019 15:31:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/data-struct/linear-struct/%E6%95%B0%E7%BB%84-%E5%8D%95%E9%93%BE%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>转载自 https://www.cnblogs.com/skywang12345/ 概要 线性表是一种线性结构，它是具有相同类型的n(n&amp;gt;=0)个元素的有序序列。本节介绍线性表的几个基本组成部分：数组、单向链表、</description>
    </item>
    
    <item>
      <title>[大型网站技术架构 | 架构模式]</title>
      <link>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 15 Oct 2019 10:13:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/books/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/1.-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题和挑战，大型互联网概述在实践中提出了许多解决方案，以实现网站高性能</description>
    </item>
    
    <item>
      <title>[实战笔记(二十二) | Go unsafe内存布局]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 14 Oct 2019 02:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>转载自 https://www.flysnow.org 简介 unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能不要使用它，如果你使用它，看到了这个名字，也会想到</description>
    </item>
    
    <item>
      <title>[实战笔记(二十一) | Go Struct Tag]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</link>
      <pubDate>Mon, 14 Oct 2019 02:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</guid>
      <description>转载自 https://www.flysnow.org JSON字符串对象转换 type User struct{ Name string `name` Age int `age` } func main(){ var u User h := `{&amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot;, &amp;quot;age&amp;quot;:15}` err := json.Unmarshall([]byte(h), &amp;amp;u) if err != nil { fmt.Println(err) }else{ fmt.Println(u) } } 上面的例子就是</description>
    </item>
    
    <item>
      <title>[实战笔记(二十) | Go 反射]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</guid>
      <description>转载自 https://www.flysnow.org 介绍 和java语言一样，Go也实现运行时反射，这为我们提供一种可以在运行时操作任意类型对象的能力。比如我们可以查看一个接口类型变量的</description>
    </item>
    
    <item>
      <title>[实战笔记(十九) | Go 基准测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是基准测试 基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底那种方案性能更好呢？这个时候基准测</description>
    </item>
    
    <item>
      <title>[实战笔记(十八) | Go 单元测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:57:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是单元测试 单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。 大多数的单元测试，都是对某一</description>
    </item>
    
    <item>
      <title>[实战笔记(十七) | Go Context]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</link>
      <pubDate>Mon, 14 Oct 2019 01:56:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</guid>
      <description>转载自 https://www.flysnow.org 前言 控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context，今天我就谈谈Context。 什么是WaitGro</description>
    </item>
    
    <item>
      <title>[实战笔记(十六) | Go Writer Reader]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</link>
      <pubDate>Mon, 14 Oct 2019 01:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</guid>
      <description>转载自 https://www.flysnow.org 输入输出 Go Writer和Reader接口的设计遵循Unix的输入输出，一个程序的输出可以是两个一个程序的输入。它们的功能单一并且纯粹</description>
    </item>
    
    <item>
      <title>[实战笔记(十五) | Go 日志]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 14 Oct 2019 01:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</guid>
      <description>转载自 https://www.flysnow.org 日志使用 日志分析，就是根据输出的日志信息，分析挖掘可能的问题，我们使用fmt.Println系列函数也可以达到目的，因为它们也可以把</description>
    </item>
    
    <item>
      <title>[实战笔记(十四) | Go 读写锁]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Mon, 14 Oct 2019 01:53:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>转载自 https://www.flysnow.org 读写锁 前面的有篇文章在讲资源竞争的时候，讲互斥锁，互斥锁的根本就是当一个goroutine访问的时候，其它goroutine都不能访</description>
    </item>
    
    <item>
      <title>[实战笔记(十三) | Go 并发示例数据库连接池]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 14 Oct 2019 01:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>转载自 https://www.flysnow.org 资源池 这篇文章演示使用有缓冲的通道实现一个资源池，这个资源池可以管理在任意多喝goroutine之间共享的资源，比如网络链接、数据库</description>
    </item>
    
    <item>
      <title>[实战笔记(十二) | Go 并发示例]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载自 https://www.flysnow.org 简介 这篇通过一个例子，演示使用通道来监控程序的执行时间，生命周期，甚至终止程序等等。我们这个程序叫runner，我们可以称之为执行者</description>
    </item>
    
    <item>
      <title>[实战笔记(十一) | Go 通道]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</link>
      <pubDate>Mon, 14 Oct 2019 01:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</guid>
      <description>转载自 https://www.flysnow.org 简介 上一篇，我们讲了原子函数和互斥锁，都可以保证共享数据的读写，但是呢，它们还是有点复杂，而且影响性能，对此，go又为我们提供了一种</description>
    </item>
    
    <item>
      <title>[实战笔记(十) | Go 资源竞争]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</link>
      <pubDate>Mon, 14 Oct 2019 01:49:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</guid>
      <description>转载自 https://www.flysnow.org 概述 有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写，就</description>
    </item>
    
    <item>
      <title>[实战笔记(九) | Go goroutine]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</link>
      <pubDate>Mon, 14 Oct 2019 01:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</guid>
      <description>转载自 https://www.flysnow.org 并发和并行 在谈goroutine之前，我们先谈谈并发和并行。 一般的程序，如果没有特殊的要求的话，是顺序执行的，这样的程序也容易编写维</description>
    </item>
    
    <item>
      <title>[实战笔记(八) | Go 标志符可见性]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Mon, 14 Oct 2019 01:47:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>转载自 https://www.flysnow.org 大小写 go的标志符，这个翻译感觉怪怪的，不过还是按这个起了标题，可以理解为go的变量、类型、字段等。这里的可见性，也就是说那些方法、</description>
    </item>
    
    <item>
      <title>[实战笔记(七) | Go 嵌入类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>转载自 https://www.flysnow.org 组合NO继承 敲入类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。 在其它语言中，有继承可以做同样</description>
    </item>
    
    <item>
      <title>[实战笔记(六) | Go 函数方法]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</guid>
      <description>转载自 https://www.flysnow.org 简介 在Go语言中，函数和方法不太一样，有明确的概念区分。函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是</description>
    </item>
    
    <item>
      <title>[实战笔记(五) | Go Map]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</link>
      <pubDate>Mon, 14 Oct 2019 01:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现(关于Hash散列细枝末节详见Java下的散列表) Map是给予散列表来实现的，就是我们常说的Hash表，所以我们每次迭代m</description>
    </item>
    
    <item>
      <title>[实战笔记(四) | Go切片]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 14 Oct 2019 01:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是</description>
    </item>
    
    <item>
      <title>[实战笔记(三) | Go数组]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。</description>
    </item>
    
    <item>
      <title>[实战笔记(二) | Go command]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</link>
      <pubDate>Mon, 14 Oct 2019 01:41:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</guid>
      <description>转载自 https://www.flysnow.org Go开发工具概览 Go is a tool for managing for Go source code. Usage: go command [arguments] The command are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate</description>
    </item>
    
    <item>
      <title>[实战笔记(一) | 包管理]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 14 Oct 2019 01:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>转载自 https://www.flysnow.org 1. 包的命名 go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样便于引用，书写以及快速定位查找。 比如go自带的htt</description>
    </item>
    
    <item>
      <title>[Golang内建类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型 聚合类型 引用类型 接口类型 无效类型 数字、字符串、布尔 数组、结构体 指针</description>
    </item>
    
    <item>
      <title>[Golang面试题]</title>
      <link>http://facedamon.github.io/post/golang/interview/golang-1/</link>
      <pubDate>Sat, 12 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/interview/golang-1/</guid>
      <description>此Golang面试题摘自网络，已经找不到作者了，所以使用someone代替。 1. 写出下面代码输出内容 package main import ( &amp;quot;fmt&amp;quot; ) func main() { defer_call() } func defer_call() { defer func() { fmt.</description>
    </item>
    
  </channel>
</rss>
