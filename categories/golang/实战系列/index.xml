<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang/实战系列 on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/categories/golang/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/</link>
    <description>Recent content in golang/实战系列 on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="http://facedamon.github.io/categories/golang/%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[实战笔记(二十二) | Go unsafe内存布局]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 14 Oct 2019 02:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>转载自 https://www.flysnow.org 简介 unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能不要使用它，如果你使用它，看到了这个名字，也会想到</description>
    </item>
    
    <item>
      <title>[实战笔记(二十一) | Go Struct Tag]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</link>
      <pubDate>Mon, 14 Oct 2019 02:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</guid>
      <description>转载自 https://www.flysnow.org JSON字符串对象转换 type User struct{ Name string `name` Age int `age` } func main(){ var u User h := `{&amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot;, &amp;quot;age&amp;quot;:15}` err := json.Unmarshall([]byte(h), &amp;amp;u) if err != nil { fmt.Println(err) }else{ fmt.Println(u) } } 上面的例子就是</description>
    </item>
    
    <item>
      <title>[实战笔记(二十) | Go 反射]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</guid>
      <description>转载自 https://www.flysnow.org 介绍 和java语言一样，Go也实现运行时反射，这为我们提供一种可以在运行时操作任意类型对象的能力。比如我们可以查看一个接口类型变量的</description>
    </item>
    
    <item>
      <title>[实战笔记(十九) | Go 基准测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是基准测试 基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底那种方案性能更好呢？这个时候基准测</description>
    </item>
    
    <item>
      <title>[实战笔记(十八) | Go 单元测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:57:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是单元测试 单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。 大多数的单元测试，都是对某一</description>
    </item>
    
    <item>
      <title>[实战笔记(十七) | Go Context]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</link>
      <pubDate>Mon, 14 Oct 2019 01:56:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</guid>
      <description>转载自 https://www.flysnow.org 前言 控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context，今天我就谈谈Context。 什么是WaitGro</description>
    </item>
    
    <item>
      <title>[实战笔记(十六) | Go Writer Reader]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</link>
      <pubDate>Mon, 14 Oct 2019 01:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</guid>
      <description>转载自 https://www.flysnow.org 输入输出 Go Writer和Reader接口的设计遵循Unix的输入输出，一个程序的输出可以是两个一个程序的输入。它们的功能单一并且纯粹</description>
    </item>
    
    <item>
      <title>[实战笔记(十五) | Go 日志]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 14 Oct 2019 01:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</guid>
      <description>转载自 https://www.flysnow.org 日志使用 日志分析，就是根据输出的日志信息，分析挖掘可能的问题，我们使用fmt.Println系列函数也可以达到目的，因为它们也可以把</description>
    </item>
    
    <item>
      <title>[实战笔记(十四) | Go 读写锁]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Mon, 14 Oct 2019 01:53:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>转载自 https://www.flysnow.org 读写锁 前面的有篇文章在讲资源竞争的时候，讲互斥锁，互斥锁的根本就是当一个goroutine访问的时候，其它goroutine都不能访</description>
    </item>
    
    <item>
      <title>[实战笔记(十三) | Go 并发示例数据库连接池]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 14 Oct 2019 01:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>转载自 https://www.flysnow.org 资源池 这篇文章演示使用有缓冲的通道实现一个资源池，这个资源池可以管理在任意多喝goroutine之间共享的资源，比如网络链接、数据库</description>
    </item>
    
    <item>
      <title>[实战笔记(十二) | Go 并发示例]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载自 https://www.flysnow.org 简介 这篇通过一个例子，演示使用通道来监控程序的执行时间，生命周期，甚至终止程序等等。我们这个程序叫runner，我们可以称之为执行者</description>
    </item>
    
    <item>
      <title>[实战笔记(十一) | Go 通道]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</link>
      <pubDate>Mon, 14 Oct 2019 01:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</guid>
      <description>转载自 https://www.flysnow.org 简介 上一篇，我们讲了原子函数和互斥锁，都可以保证共享数据的读写，但是呢，它们还是有点复杂，而且影响性能，对此，go又为我们提供了一种</description>
    </item>
    
    <item>
      <title>[实战笔记(十) | Go 资源竞争]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</link>
      <pubDate>Mon, 14 Oct 2019 01:49:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</guid>
      <description>转载自 https://www.flysnow.org 概述 有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写，就</description>
    </item>
    
    <item>
      <title>[实战笔记(九) | Go goroutine]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</link>
      <pubDate>Mon, 14 Oct 2019 01:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</guid>
      <description>转载自 https://www.flysnow.org 并发和并行 在谈goroutine之前，我们先谈谈并发和并行。 一般的程序，如果没有特殊的要求的话，是顺序执行的，这样的程序也容易编写维</description>
    </item>
    
    <item>
      <title>[实战笔记(八) | Go 标志符可见性]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Mon, 14 Oct 2019 01:47:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>转载自 https://www.flysnow.org 大小写 go的标志符，这个翻译感觉怪怪的，不过还是按这个起了标题，可以理解为go的变量、类型、字段等。这里的可见性，也就是说那些方法、</description>
    </item>
    
    <item>
      <title>[实战笔记(七) | Go 嵌入类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>转载自 https://www.flysnow.org 组合NO继承 敲入类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。 在其它语言中，有继承可以做同样</description>
    </item>
    
    <item>
      <title>[实战笔记(六) | Go 函数方法]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</guid>
      <description>转载自 https://www.flysnow.org 简介 在Go语言中，函数和方法不太一样，有明确的概念区分。函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是</description>
    </item>
    
    <item>
      <title>[实战笔记(五) | Go Map]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</link>
      <pubDate>Mon, 14 Oct 2019 01:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现(关于Hash散列细枝末节详见Java下的散列表) Map是给予散列表来实现的，就是我们常说的Hash表，所以我们每次迭代m</description>
    </item>
    
    <item>
      <title>[实战笔记(四) | Go切片]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 14 Oct 2019 01:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是</description>
    </item>
    
    <item>
      <title>[实战笔记(三) | Go数组]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。</description>
    </item>
    
    <item>
      <title>[实战笔记(二) | Go command]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</link>
      <pubDate>Mon, 14 Oct 2019 01:41:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</guid>
      <description>转载自 https://www.flysnow.org Go开发工具概览 Go is a tool for managing for Go source code. Usage: go command [arguments] The command are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate</description>
    </item>
    
    <item>
      <title>[实战笔记(一) | 包管理]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 14 Oct 2019 01:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>转载自 https://www.flysnow.org 1. 包的命名 go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样便于引用，书写以及快速定位查找。 比如go自带的htt</description>
    </item>
    
    <item>
      <title>[Golang内建类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型 聚合类型 引用类型 接口类型 无效类型 数字、字符串、布尔 数组、结构体 指针</description>
    </item>
    
  </channel>
</rss>
