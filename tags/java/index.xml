<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/tags/java/</link>
    <description>Recent content in Java on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 20 Mar 2021 15:01:56 +0800</lastBuildDate><atom:link href="http://facedamon.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[mybatis源码(二) | 核心组件]</title>
      <link>http://facedamon.github.io/post/java/mybatis/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 20 Mar 2021 15:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/mybatis/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</guid>
      <description>摘要 SqlSession是MyBatis提供的面向用户的操作数据库API。那么MyBatis底层是如何工作的呢？为了解开MyBatis的神秘</description>
    </item>
    
    <item>
      <title>[mybatis源码(一) | 工具类]</title>
      <link>http://facedamon.github.io/post/java/mybatis/%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Fri, 19 Mar 2021 11:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/mybatis/%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>工具类 SQL构造器 为了解决代码中sql拼接问题，mybatis中提供了一个sql工具类。使用这个工具类，我们可以很方便地在Java代码中动态</description>
    </item>
    
    <item>
      <title>[Java | 生产消费问题]</title>
      <link>http://facedamon.github.io/post/java/thread/4.producer/</link>
      <pubDate>Thu, 21 Jan 2021 18:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/4.producer/</guid>
      <description>模型 生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下： 生产者仅仅在仓</description>
    </item>
    
    <item>
      <title>[Java | 线程等待于唤醒]</title>
      <link>http://facedamon.github.io/post/java/thread/3.wait/</link>
      <pubDate>Thu, 21 Jan 2021 15:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/3.wait/</guid>
      <description>摘要 在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状</description>
    </item>
    
    <item>
      <title>[Java | synchronized]</title>
      <link>http://facedamon.github.io/post/java/thread/2.synchronized/</link>
      <pubDate>Wed, 20 Jan 2021 21:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/2.synchronized/</guid>
      <description>原理 在Java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在的 当我们调用某个对象的synchronized方法时，就</description>
    </item>
    
    <item>
      <title>[Java | 多线程基本概念]</title>
      <link>http://facedamon.github.io/post/java/thread/1.gainian/</link>
      <pubDate>Wed, 20 Jan 2021 20:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/1.gainian/</guid>
      <description>摘要 多线程是Java中不可避免的一个重要主体。从本章开始，我们将展开对多线程的学习。接下来的内容，是对“JDK中新增JUC包”之前的Java</description>
    </item>
    
    <item>
      <title>[Java | 抽象类与接口]</title>
      <link>http://facedamon.github.io/post/java/base/4.abstract-interface/</link>
      <pubDate>Tue, 19 Jan 2021 17:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/4.abstract-interface/</guid>
      <description>摘要 抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之多态]</title>
      <link>http://facedamon.github.io/post/java/base/3.duotai/</link>
      <pubDate>Tue, 19 Jan 2021 15:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/3.duotai/</guid>
      <description>摘要 面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之继承]</title>
      <link>http://facedamon.github.io/post/java/base/2.extends/</link>
      <pubDate>Sun, 17 Jan 2021 17:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/2.extends/</guid>
      <description>摘要 在《Thinnk in Java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但是要想成为极具革命性的语言，仅仅能够复制代码并对</description>
    </item>
    
    <item>
      <title>[Java | 三大特性之封装]</title>
      <link>http://facedamon.github.io/post/java/base/1.fengzhuang/</link>
      <pubDate>Sun, 17 Jan 2021 17:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/base/1.fengzhuang/</guid>
      <description>摘要 封装从字面上来理解就是包装的意思，就是隐藏信息，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数</description>
    </item>
    
    <item>
      <title>[Java | TreeMap]</title>
      <link>http://facedamon.github.io/post/java/collection/treemap/</link>
      <pubDate>Mon, 11 Jan 2021 16:26:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/treemap/</guid>
      <description>摘要 之前的文章讲解了两种Map，分别是HashMap与LinkedHashMap，它们保证了以O(1)的时间复杂度进行增、删、改、查，从存储</description>
    </item>
    
    <item>
      <title>[Java | LinkedHashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/linkedhashmap/</link>
      <pubDate>Mon, 11 Jan 2021 14:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/linkedhashmap/</guid>
      <description>摘要 大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是迭代HashMap的顺序并不</description>
    </item>
    
    <item>
      <title>[Java | ConcurrentHashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/concurrenthashmap/</link>
      <pubDate>Sat, 09 Jan 2021 18:11:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/concurrenthashmap/</guid>
      <description>背景 线程不安全的HashMap 因为多线程环境下，使用HashMap扩容操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使</description>
    </item>
    
    <item>
      <title>[Java | HashMap引发死循环]</title>
      <link>http://facedamon.github.io/post/java/collection/hashmaprehash/</link>
      <pubDate>Sat, 09 Jan 2021 15:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/hashmaprehash/</guid>
      <description>摘要 上一篇文章了解了HashMap的实现原理，讲到了HashMap不是线程安全的。那么HashMap在多线程环境下又会有什么问题呢？先来看一</description>
    </item>
    
    <item>
      <title>[Java | HashMap]</title>
      <link>http://facedamon.github.io/post/java/collection/hashmap/</link>
      <pubDate>Fri, 08 Jan 2021 16:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/hashmap/</guid>
      <description>摘要 对于集合，我认为关注的点主要有四点： 关注点 结论 HashMap是否允许null Key和Value都允许为空 HashMap是否允许重复数据 K</description>
    </item>
    
    <item>
      <title>[Java | LinkedList]</title>
      <link>http://facedamon.github.io/post/java/collection/linkedlist/</link>
      <pubDate>Thu, 07 Jan 2021 19:10:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/linkedlist/</guid>
      <description>摘要 LinkedList是基于链表实现的，所以先讲解一下什么是链表。链表原先是C/C++的概念，是一种线性的存储结构，意思是将要存储的数据存</description>
    </item>
    
    <item>
      <title>[Java | CopyOnWriteArrayList]</title>
      <link>http://facedamon.github.io/post/java/collection/copyonwritearraylist/</link>
      <pubDate>Thu, 07 Jan 2021 18:34:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/copyonwritearraylist/</guid>
      <description>摘要 CopyOnWriteArrayList位于java.util.concurrent包下，可想而知，这个类是为并发而设计的。 CopyOn</description>
    </item>
    
    <item>
      <title>[Java | ArrayList]</title>
      <link>http://facedamon.github.io/post/java/collection/arraylist/</link>
      <pubDate>Thu, 07 Jan 2021 18:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/arraylist/</guid>
      <description>摘要 对于集合，我认为关注的点主要有四点： 关注点 结论 ArrayList是否允许null 允许 ArrayList是否允许重复数据 允许 ArrayLi</description>
    </item>
    
    <item>
      <title>[Java | 集合框架概述]</title>
      <link>http://facedamon.github.io/post/java/collection/%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 06 Jan 2021 18:04:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/collection/%E6%9E%B6%E6%9E%84/</guid>
      <description>集合框架图 所有集合类都位于java.util包下。Java集合类主要由两个接口派生：Collection和Map，Collection和Ma</description>
    </item>
    
    <item>
      <title>[Java | 乐观锁与悲观锁]</title>
      <link>http://facedamon.github.io/post/java/thread/sync/</link>
      <pubDate>Sat, 02 Jan 2021 17:28:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/sync/</guid>
      <description>摘要 乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会</description>
    </item>
    
    <item>
      <title>[Java | 什么是线程安全]</title>
      <link>http://facedamon.github.io/post/java/thread/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</link>
      <pubDate>Thu, 24 Dec 2020 16:25:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/java/thread/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</guid>
      <description>转载自 https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html 不是线程的安全 面试官问：“什么是线程安全”，如果你不能很好的回答，那就请往下看吧。 论语中有句叫“学而优则仕”，相信很多人都觉得是“学</description>
    </item>
    
  </channel>
</rss>
