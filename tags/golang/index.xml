<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on FaceDamon`s Blog</title>
    <link>http://facedamon.github.io/tags/golang/</link>
    <description>Recent content in golang on FaceDamon`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 21 Oct 2020 15:14:56 +0800</lastBuildDate><atom:link href="http://facedamon.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[分布式缓存 (七) | Protobuf]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</link>
      <pubDate>Wed, 21 Oct 2020 15:14:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rpc/</guid>
      <description>为什么要使用protobuf protobuf既Protocol Buffers, Google开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语</description>
    </item>
    
    <item>
      <title>[分布式缓存 (六) | 防止缓存击穿]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</link>
      <pubDate>Wed, 21 Oct 2020 10:16:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</guid>
      <description>摘要 缓存雪崩：缓存在同一时刻全部失效，造成瞬间DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的key设置了相同的过期</description>
    </item>
    
    <item>
      <title>[分布式缓存 (五) | 分布式节点]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 20 Oct 2020 10:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8F%E8%8A%82%E7%82%B9/</guid>
      <description>流程回顾 接收key --&amp;gt; 检查是否被缓存 ---是---&amp;gt; 返回缓存值(1) |否 |------&amp;gt;是否应当从远程节点获取 ------&amp;gt; 与远程节点交互 ---&amp;gt; 返</description>
    </item>
    
    <item>
      <title>[分布式缓存 (四) | 一致性HASH]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</link>
      <pubDate>Mon, 19 Oct 2020 09:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-hash/</guid>
      <description>摘要 今天我们要实现的是一致性哈希算法，一致性哈希算法是Geec从单节点走向分布式节点的一个重要的环节。 我该访问谁 对于分布式缓存来说，当一个节</description>
    </item>
    
    <item>
      <title>[分布式缓存 (三) | HTTP]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</link>
      <pubDate>Fri, 24 Jul 2020 16:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-http/</guid>
      <description>摘要 分布式缓存需要实现节点间通信，建立基于HTTP的通信机制是比较常见的做法。如果一个节点启动了HTTP服务， 那么这个节点就可以被其它节点访</description>
    </item>
    
    <item>
      <title>[分布式缓存 (二) | 确保一致性]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</link>
      <pubDate>Mon, 20 Jul 2020 15:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-rwmutex/</guid>
      <description>摘要 在上一篇博客中，我们实现了LRU缓存淘汰策略。接下来我们使用sync.RWMutex封装LRU的几个方法，使之支持并发的读写。(对于并发</description>
    </item>
    
    <item>
      <title>[分布式缓存 (一) | LRU 淘汰策略]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</link>
      <pubDate>Mon, 20 Jul 2020 10:32:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-lru/</guid>
      <description>淘汰算法简介 geec的缓存全部存储在内存中，内存是有限的，因此不可能无限制添加数据。假定，我们设置缓存能够使用的内存大小为N,那么在某一个时</description>
    </item>
    
    <item>
      <title>[谈谈分布式缓存 (零) | golang cache]</title>
      <link>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 20 Jul 2020 09:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/cache/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</guid>
      <description>摘要 第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。我想这是大部分人对于缓存的理解。在计算机系统中，缓存无处不</description>
    </item>
    
    <item>
      <title>[手写http框架 (六) | golang recover]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</link>
      <pubDate>Fri, 17 Jul 2020 09:22:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-recover/</guid>
      <description>摘要 在go中，比较常见的错误处理方式是返回error，由调用者巨顶后续如何处理。但是如果是无法恢复的错误，可以手动触发panic，当然如果在</description>
    </item>
    
    <item>
      <title>[手写http框架 (五) | golang middleware]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</link>
      <pubDate>Thu, 16 Jul 2020 10:30:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-middleware/</guid>
      <description>摘要 中间件(middleware)，简单的说，就是非业务的技术类组件。http框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此</description>
    </item>
    
    <item>
      <title>[手写http框架 (四) | golang group]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</link>
      <pubDate>Thu, 16 Jul 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-group/</guid>
      <description>摘要 分组控制是http框架提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景</description>
    </item>
    
    <item>
      <title>[手写http框架 (三) | golang router]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</link>
      <pubDate>Tue, 14 Jul 2020 16:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-router/</guid>
      <description>摘要 使用trie树实现动态路由解析 支持两种模式:name和*filepath trie树 上一节，我们用了一个非常简单的map结果来存储了路由表</description>
    </item>
    
    <item>
      <title>[手写http框架 (二) | golang context]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</link>
      <pubDate>Wed, 24 Jun 2020 11:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-context/</guid>
      <description>摘要 将路由router独立出来，方便之后增强。 设计上下文context，封装Request和Response，提供对JSON、HTML等返回</description>
    </item>
    
    <item>
      <title>[手写http框架 (一) | golang http-handler]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</link>
      <pubDate>Tue, 23 Jun 2020 15:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-%E6%89%8B%E5%86%99http%E6%A1%86%E6%9E%B6-httphandler/</guid>
      <description>摘要 简单介绍net/http库以及http.Handler接口 搭建Gee框架的雏形 标准库启动Web服务 Go语言内置了net/http库，封装</description>
    </item>
    
    <item>
      <title>[HTTP | golang net/http 源码解读]</title>
      <link>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 20 Jun 2020 10:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/http/golang-http%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>重要接口 接口名称 简略含义 Handler 处理请求接口 ResponseWriter 返回响应接口 ServeMux 路由 Conn tcp连接 Handler type Handler interface { ServeHTTP(ResponseWriter, *Request) } Handler接口是一个逻辑接口，所有的请求都会进入该</description>
    </item>
    
    <item>
      <title>[杂谈 | golang接口型函数]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 22 May 2020 09:19:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%8E%A5%E5%8F%A3%E5%9E%8B%E5%87%BD%E6%95%B0/</guid>
      <description>转载自 https://www.flysnow.org/2016/12/30/golang-function-interface.html 简介 接口型函数，指的是用函数实现接口，这样在调用的时候就会非常简便，这种方式使用于只有一个函数的接口。 原始接口 我们以迭代一个map为</description>
    </item>
    
    <item>
      <title>[杂谈 | golang database/sql使用]</title>
      <link>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang-database/sql%E4%BD%BF%E7%94%A8/</guid>
      <description>转载自 https://segmentfault.com/a/1190000003036452 概述 sql.DB不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙</description>
    </item>
    
    <item>
      <title>[golang base(十一) | 分布式网络爬虫]</title>
      <link>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 06 Mar 2020 17:08:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/11.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>原因 有一定的复杂性 可以灵活调整项目的复杂性 平衡语言/爬虫之间的比重 爬虫分类 通用爬虫，如baidu，google 聚焦爬虫，从互联网获取结构化数</description>
    </item>
    
    <item>
      <title>[golang base(十) | 广度优先搜索]</title>
      <link>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Thu, 05 Mar 2020 15:29:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/10.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
      <description>广度优先算法 为爬虫实战做好准备 应用广泛，综合性强 面试常见 上图中是一个6*5的迷宫，0 代表可以走，1 代表墙，从左上角进右下角出，只能上左下右，</description>
    </item>
    
    <item>
      <title>[golang base(九) | 标准库]</title>
      <link>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Thu, 05 Mar 2020 14:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/9.http%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>http 使用http客户端发送请求 使用http.Client控制请求头部等 使用httputil简化工作 package main func main(){ // 访问手机版imooc r, err := http.NewRequest(http.MethodGet, &amp;quot;http://www.imooc.com&amp;quot;, nil) r.Header.Add(&amp;quot;User-Agent&amp;quot;,</description>
    </item>
    
    <item>
      <title>[golang base(八) | 再谈channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.channel/</link>
      <pubDate>Wed, 04 Mar 2020 20:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.channel/</guid>
      <description>转载自 https://www.cnblogs.com/sparkdev/ 转载自 https://go-zh.org/ref/mem golang官网内存模型分析 转载自 https://taohuawu.club/high-performance-implementation-of-goroutine-pool 忠告 程序在修改被多个Go程同时访问的数据时必须序列化该访问。要序列化访问，需要通过Cha</description>
    </item>
    
    <item>
      <title>[golang base(八) | goroutine &amp; channel]</title>
      <link>http://facedamon.github.io/post/golang/base/8.-goroutine/</link>
      <pubDate>Wed, 04 Mar 2020 20:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/8.-goroutine/</guid>
      <description>goroutine package main func main() { for i := 0; i &amp;lt; 10; i++ { go func(i int){ for { fmt.Printf(&amp;quot;Hello from goroutine %d\n&amp;quot;, i) } }(i) } time.Sleep(time.Millisecond) } 如果不加go关键字的话，就是外循环进来一次一直执行匿名函数，不会退出。加了go关</description>
    </item>
    
    <item>
      <title>[golang base(七) | 测试与性能调优]</title>
      <link>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</link>
      <pubDate>Sun, 01 Mar 2020 13:05:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/7.%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</guid>
      <description>Debugging Sucks and Testing Rocks 测试 传统测试 VS 表格驱动测试 传统测试 @Test public void testAdd() { assertEquals(3, add(1, 2)); assertEquals(Integer.MIN_VALUE, add(1, Integer.MAX_VALUE)); } 测试数据和测试逻辑混在一起 出错信息不明确 一旦一个数据出错测试全部结束 表格</description>
    </item>
    
    <item>
      <title>[golang base(六) | 错误处理]</title>
      <link>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 28 Feb 2020 17:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/6.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>资源管理与出错处理 defer调用 确保在函数结束时调用 package main func tryDefer() { defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(&amp;quot;error occurr&amp;quot;) //触发return fmt.Println(4) } func writeFile(filename string) { file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE, 0666) if err != nil { panic(err) } defer file.Close() writer</description>
    </item>
    
    <item>
      <title>[golang base(五) | 函数式编程]</title>
      <link>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 28 Feb 2020 17:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>函数式编程 函数式编程 VS 函数指针 函数是一等公民：参数，变量，返回值都可以是函数 闭包 package main func adder() func(int) int { sum := 0 // 自由变量 return func (v int) int { sum += v //v 局部变量 return</description>
    </item>
    
    <item>
      <title>[golang base(四) | 面向接口]</title>
      <link>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 28 Feb 2020 17:23:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/4.%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口 duck typing 大黄鸭是不是一个鸭子? 传统类型系统：脊索动物，脊椎动物亚门，鸟纲雁形目。。。:no duck typing :yes，像鸭子走路，像鸭子叫，那么就是鸭子 描</description>
    </item>
    
    <item>
      <title>[golang base(三) | 面向对象]</title>
      <link>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 28 Feb 2020 17:07:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/3.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>结构体和方法 golang仅支持封装，不支持继承和多态 golang没有class，只有struct golang结构体没有构造方法这一说法 type treeNode struct</description>
    </item>
    
    <item>
      <title>[golang base(二) | 内建容器]</title>
      <link>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Fri, 28 Feb 2020 15:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/2.%E5%86%85%E5%BB%BA%E5%AE%B9%E5%99%A8/</guid>
      <description>数组 数量写在类型的前面 func main() { // var 需要确定大小，可以不用初始化赋值 var arr1 [5]int // 简化，需要确定大小，需要初始化赋值 arr2 := [3]int{1, 3, 5} // ... 编译器根据初始化赋值</description>
    </item>
    
    <item>
      <title>[golang base(一) | 基础语法]</title>
      <link>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 28 Feb 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/base/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>变量定义 在golang中变量名在前变量类型在后 这样设计的初衷是什么?我们回想一下使用其它语言的变量的时候是先想到变量的名字还是先想到变量类型</description>
    </item>
    
    <item>
      <title>[杂谈 | golang设计哲学 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</link>
      <pubDate>Thu, 02 Jan 2020 14:21:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</guid>
      <description>世界是并行的 先不说宇宙，就整个地球来说，世界万物都是并行发生的；天生对并发支持良好的go语言更容易描述并行的世界。 #世界是由物质组合构成的 微</description>
    </item>
    
    <item>
      <title>[杂谈 | golang发现序列]</title>
      <link>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 02 Jan 2020 14:09:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E5%8F%91%E7%8E%B0%E5%BA%8F%E5%88%97/</guid>
      <description>发现了一个好用的golang sql package sqlx，有点类似与java中的dbutils，可以实现结果集的自动映射 sqlx它没有传统ORM的繁琐，毕竟</description>
    </item>
    
    <item>
      <title>[杂谈 | golang是值传递 ]</title>
      <link>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</link>
      <pubDate>Thu, 02 Jan 2020 12:36:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/golang%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/</guid>
      <description>什么是值传递 值传递的意思是：函数传递总是原来这个东西的一个副本，一幅拷贝。比如我们传递一个int类型的参数，传递的其实是这个参数的一个副本；</description>
    </item>
    
    <item>
      <title>[实战笔记(二十二) | Go unsafe内存布局]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link>
      <pubDate>Mon, 14 Oct 2019 02:01:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%BA%8C-go-unsafe%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid>
      <description>转载自 https://www.flysnow.org 简介 unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能不要使用它，如果你使用它，看到了这个名字，也会想到</description>
    </item>
    
    <item>
      <title>[实战笔记(二十一) | Go Struct Tag]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</link>
      <pubDate>Mon, 14 Oct 2019 02:00:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81%E4%B8%80-go-struct-tag/</guid>
      <description>转载自 https://www.flysnow.org JSON字符串对象转换 type User struct{ Name string `name` Age int `age` } func main(){ var u User h := `{&amp;quot;name&amp;quot;: &amp;quot;张三&amp;quot;, &amp;quot;age&amp;quot;:15}` err := json.Unmarshall([]byte(h), &amp;amp;u) if err != nil { fmt.Println(err) }else{ fmt.Println(u) } } 上面的例子就是</description>
    </item>
    
    <item>
      <title>[实战笔记(二十) | Go 反射]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:59:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C%E5%8D%81-go-%E5%8F%8D%E5%B0%84/</guid>
      <description>转载自 https://www.flysnow.org 介绍 和java语言一样，Go也实现运行时反射，这为我们提供一种可以在运行时操作任意类型对象的能力。比如我们可以查看一个接口类型变量的</description>
    </item>
    
    <item>
      <title>[实战笔记(十九) | Go 基准测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:58:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B9%9D-go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是基准测试 基准测试，是一种测试代码性能的方法，比如你有多种不同的方案，都可以解决问题，那么到底那种方案性能更好呢？这个时候基准测</description>
    </item>
    
    <item>
      <title>[实战笔记(十八) | Go 单元测试]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:57:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB-go-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>转载自 https://www.flysnow.org 什么是单元测试 单元测试一般是用来测试我们的代码逻辑有没有问题，有没有按照我们期望的运行，以保证代码质量。 大多数的单元测试，都是对某一</description>
    </item>
    
    <item>
      <title>[实战笔记(十七) | Go Context]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</link>
      <pubDate>Mon, 14 Oct 2019 01:56:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83-go-context/</guid>
      <description>转载自 https://www.flysnow.org 前言 控制并发有两种经典的方式，一种是WaitGroup，另外一种就是Context，今天我就谈谈Context。 什么是WaitGro</description>
    </item>
    
    <item>
      <title>[实战笔记(十六) | Go Writer Reader]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</link>
      <pubDate>Mon, 14 Oct 2019 01:55:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD-go-writer-reader/</guid>
      <description>转载自 https://www.flysnow.org 输入输出 Go Writer和Reader接口的设计遵循Unix的输入输出，一个程序的输出可以是两个一个程序的输入。它们的功能单一并且纯粹</description>
    </item>
    
    <item>
      <title>[实战笔记(十五) | Go 日志]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 14 Oct 2019 01:54:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94-go-%E6%97%A5%E5%BF%97/</guid>
      <description>转载自 https://www.flysnow.org 日志使用 日志分析，就是根据输出的日志信息，分析挖掘可能的问题，我们使用fmt.Println系列函数也可以达到目的，因为它们也可以把</description>
    </item>
    
    <item>
      <title>[实战笔记(十四) | Go 读写锁]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Mon, 14 Oct 2019 01:53:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B-go%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>转载自 https://www.flysnow.org 读写锁 前面的有篇文章在讲资源竞争的时候，讲互斥锁，互斥锁的根本就是当一个goroutine访问的时候，其它goroutine都不能访</description>
    </item>
    
    <item>
      <title>[实战笔记(十三) | Go 并发示例数据库连接池]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Mon, 14 Oct 2019 01:52:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>转载自 https://www.flysnow.org 资源池 这篇文章演示使用有缓冲的通道实现一个资源池，这个资源池可以管理在任意多喝goroutine之间共享的资源，比如网络链接、数据库</description>
    </item>
    
    <item>
      <title>[实战笔记(十二) | Go 并发示例]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:51:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C-go%E5%B9%B6%E5%8F%91%E7%A4%BA%E4%BE%8B/</guid>
      <description>转载自 https://www.flysnow.org 简介 这篇通过一个例子，演示使用通道来监控程序的执行时间，生命周期，甚至终止程序等等。我们这个程序叫runner，我们可以称之为执行者</description>
    </item>
    
    <item>
      <title>[实战笔记(十一) | Go 通道]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</link>
      <pubDate>Mon, 14 Oct 2019 01:50:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80-go%E9%80%9A%E9%81%93/</guid>
      <description>转载自 https://www.flysnow.org 简介 上一篇，我们讲了原子函数和互斥锁，都可以保证共享数据的读写，但是呢，它们还是有点复杂，而且影响性能，对此，go又为我们提供了一种</description>
    </item>
    
    <item>
      <title>[实战笔记(十) | Go 资源竞争]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</link>
      <pubDate>Mon, 14 Oct 2019 01:49:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%8D%81-%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89/</guid>
      <description>转载自 https://www.flysnow.org 概述 有并发，就有资源竞争，如果两个或者多个goroutine在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写，就</description>
    </item>
    
    <item>
      <title>[实战笔记(九) | Go goroutine]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</link>
      <pubDate>Mon, 14 Oct 2019 01:48:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B9%9D-go-goroutine/</guid>
      <description>转载自 https://www.flysnow.org 并发和并行 在谈goroutine之前，我们先谈谈并发和并行。 一般的程序，如果没有特殊的要求的话，是顺序执行的，这样的程序也容易编写维</description>
    </item>
    
    <item>
      <title>[实战笔记(八) | Go 标志符可见性]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</link>
      <pubDate>Mon, 14 Oct 2019 01:47:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AB-go%E6%A0%87%E5%BF%97%E7%AC%A6%E5%8F%AF%E8%A7%81%E6%80%A7/</guid>
      <description>转载自 https://www.flysnow.org 大小写 go的标志符，这个翻译感觉怪怪的，不过还是按这个起了标题，可以理解为go的变量、类型、字段等。这里的可见性，也就是说那些方法、</description>
    </item>
    
    <item>
      <title>[实战笔记(七) | Go 嵌入类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:46:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%83-go%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B/</guid>
      <description>转载自 https://www.flysnow.org 组合NO继承 敲入类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。 在其它语言中，有继承可以做同样</description>
    </item>
    
    <item>
      <title>[实战笔记(六) | Go 函数方法]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 14 Oct 2019 01:45:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%85%AD-go%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95/</guid>
      <description>转载自 https://www.flysnow.org 简介 在Go语言中，函数和方法不太一样，有明确的概念区分。函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的；而方法是</description>
    </item>
    
    <item>
      <title>[实战笔记(五) | Go Map]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</link>
      <pubDate>Mon, 14 Oct 2019 01:44:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%94-go-map/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现(关于Hash散列细枝末节详见Java下的散列表) Map是给予散列表来实现的，就是我们常说的Hash表，所以我们每次迭代m</description>
    </item>
    
    <item>
      <title>[实战笔记(四) | Go切片]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 14 Oct 2019 01:43:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E5%9B%9B-go%E5%88%87%E7%89%87/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是</description>
    </item>
    
    <item>
      <title>[实战笔记(三) | Go数组]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Oct 2019 01:42:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%89-go%E6%95%B0%E7%BB%84/</guid>
      <description>转载自 https://www.flysnow.org 1. 内部实现 要想更清晰的了解数组，我们得了解它的内部实现。数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。</description>
    </item>
    
    <item>
      <title>[实战笔记(二) | Go command]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</link>
      <pubDate>Mon, 14 Oct 2019 01:41:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%BA%8C-go-command/</guid>
      <description>转载自 https://www.flysnow.org Go开发工具概览 Go is a tool for managing for Go source code. Usage: go command [arguments] The command are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information bug start a bug report fix run go tool fix on packages fmt run gofmt on package sources generate generate</description>
    </item>
    
    <item>
      <title>[实战笔记(一) | 包管理]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 14 Oct 2019 01:40:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>转载自 https://www.flysnow.org 1. 包的命名 go语言的包的命名，遵循简洁、小写、和go文件所在目录同名的原则，这样便于引用，书写以及快速定位查找。 比如go自带的htt</description>
    </item>
    
    <item>
      <title>[Golang内建类型]</title>
      <link>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 14 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/effective-golang/%E5%86%85%E5%BB%BA%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型 聚合类型 引用类型 接口类型 无效类型 数字、字符串、布尔 数组、结构体 指针</description>
    </item>
    
    <item>
      <title>[Golang面试题]</title>
      <link>http://facedamon.github.io/post/golang/interview/golang-1/</link>
      <pubDate>Sat, 12 Oct 2019 01:37:56 +0800</pubDate>
      
      <guid>http://facedamon.github.io/post/golang/interview/golang-1/</guid>
      <description>此Golang面试题摘自网络，已经找不到作者了，所以使用someone代替。 1. 写出下面代码输出内容 package main import ( &amp;quot;fmt&amp;quot; ) func main() { defer_call() } func defer_call() { defer func() { fmt.</description>
    </item>
    
  </channel>
</rss>
